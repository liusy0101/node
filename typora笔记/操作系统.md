[toc]



记录自：拉钩教育-重学操作系统

# 操作系统



## 一、计算机组成原理

### 1、计算机组成

计算机结构分成五个部分：

- 输入设备
- 输出设备
- 内存
- 中央处理器
- 总线

这就是冯诺依曼模型



#### （1）内存

 程序和数据都被存储在一个被称为内存的线性排列存储区域。

存储的数据单位是一个二进制位，最小的存储单位叫做字节，8byte，每个字节对应一个内存地址，内存地址由0开始编号，比如第一个地址是0，第二个地址是1.然后自增排列。

内存是随机存取器，读取或者写入任何一个地址数据的速度是一样的



#### （2）CPU

CPU负责控制和计算。为了方便计算较大的数值，CPU每次可计算多个字节的数据。

- 每次可计算4个byte，称为32位CPU
- 每次可计算8个byte，称为64位CPU

32和64，指的是CPU的位宽。

32位CPU能计算的最大整数事2^32-1，也就是4,294,967,295



##### 1、控制单元和逻辑单元

CPU中有一个控制单元专门负责控制CPU工作；

逻辑运算单元专门负责计算。



##### 2、寄存器

CPU在进行计算的时候，需要有地方存储中间结果，由于CPU离内存远，所以需要一种离自己近的存储来存储将要被计算的数字。

这种存储就是寄存器，寄存器就在CPU里，控制单元和逻辑运算单元非常近，因此运算速度显著提升。



**通用寄存器：**

寄存器中有一部分是提供给用户编程使用的，比如用来存加和指令的两个参数



**特殊寄存器：**

还有一部分寄存器有特殊的用途，叫作特殊寄存器。比如程序指针，就是一个特殊寄存器。它存储了 CPU 要执行的下一条指令所在的内存地址。注意，程序指针不是存储了下一条要执行的指令，此时指令还在内存中，程序指针只是存储了下一条指令的地址。



**指令寄存器：**

存储下一条要执行的指令，会从内存读入到这个指令寄存器里，指令被执行完成之前，指令都存储在这里。



#### （3）总线

CPU和内存以及其它设备之间，也需要通信，因此用这种特殊的设备进行控制，就是总线。

总线分成3种：

- 地址总线，专门用来指定CPU将要操作的内存地址
- 数据总线，用来读写内存中的数据
- 控制总线，用来发送和接受关键信号，比如中断信号、设备复位等信号，都是通过控制总线传输，同样，CPU需要堆这些信号进行响应，也需要控制总线。

当CPU需要读写内存的时候，先要通过地址总线来指定内存地址，再通过数据总线来传输数据。



#### （4）输入、输出设备

输入设备向计算机输入数据，计算机经过计算，将结果通过输出设备向外界传达。

如果输入、输出设备需要和CPU进行交互，就需要用到控制总线







#### （5）问题

##### 1、线路位宽问题

**数据如何通过线路传递？**

通过操作电压，低电压是0，高电压是1



如果只有一条线路，每次只能传递一个信号，0或者1，假若要传递数字10，也就是1100，那么就需要传递4次。

这种称为串行，如果需要每次多传一些数据，就需要增加线路，也就是并行。

如果只有 1 条地址总线，那每次只能表示 0-1 两种情况，所以只能操作 2 个内存地址；如果有 10 条地址总线，一次就可以表示 210 种情况，也就是可以操作 1024 个内存地址；如果你希望操作 4G 的内存，那么就需要 32 条线，因为 232 是 4G。



##### 2、64位和32位的计算

**CPU的位宽会对计算造成什么影响？**

如果要在32位的CPU上计算两个64位数字和的操作，就需要将64 位数字拆成 2 个 32 位数字来计算，这样就需要一个算法，比如用像小时候做加法竖式一样，先加和两个低位的 32 位数字，算出进位，然后加和两个高位的 32 位数字，最后再加上进位。

而 64 位的 CPU 就可以一次读入 64 位的数字，同时 64 位的 CPU 内部的逻辑计算单元，也支持 64 位的数字进行计算。但是你千万不要仅仅因为位宽的区别，就认为 64 位 CPU 性能比 32 位高很多。

还有一点要注意，32 位宽的 CPU 没办法控制超过 32 位的地址总线、数据总线工作。比如说你有一条 40 位的地址总线（其实就是 40 条线），32 位的 CPU 没有办法一次给 40 个信号，因为它最多只有 32 位的寄存器。因此 32 位宽的 CPU 最多操作 232 个内存地址，也就是 4G 内存地址。







#### （6）程序的执行过程

当CPU执行程序的时候：

1. CPU读取PC指针指向的指令，将它导入指令寄存器。

- CPU的控制单元操作地址总线指定需要访问的内存地址（把PC指针种的值拷贝到地址总线中）

- CPU通知内存设备准备数据（内存设备准备好了，通过数据总线将数据传送给CPU）

- CPU收到内存传来的数据后，将这个数据存入指令寄存器

  上述3步完成后，CPU成功读取了PC指针指向的指令，存入了指令寄存器

2. CPU分析指令寄存器中的指令，确定指令的类型和参数
3. 如果是计算类型的指令，就较给逻辑运算单元计算；如果是存储类型的指令，就由控制单元执行
4. PC指针自增，并准备获取下一条指令。

比如在 32 位的机器上，指令是 32 位 4 个字节，需要 4 个内存地址存储，因此 PC 指针会自增 4。

![image-20210703222712744](typora-user-images/image-20210703222712744.png)



程序指针也是一个寄存器，64位的CPU会提供64位的寄存器，就可使用更多内存地址。64位的寄存器可寻址的范围非常大，但也会收到地址总线条数的限制。比如和64位CPU配套工作的地址总线只有40条，那么可寻址的范围就是2^40=1T





从PC指针读取指令、到执行、再到下一跳指令，构成了一个循环，这个不断循环的过程叫做**CPU的指令周期**



#### （7）CPU的指令周期

例如a=11+15是怎么执行的。

1. 编译器通过分析，发现11和15是数据，因此编译好的程序启动时，会在内存中开辟出一个区域存这样的常数，这个专门用来存储常数的区域，就是数据段：

11被存储到地址0x100，15被存储到了0x104

![1.png](typora-user-images/Ciqc1F9jNVKAbRJhAADt2il2zYI826.png)



2. 编译器将a=11+15转换成4条指令，程序启动后，这些指令被导入了一个专门用来存储指令的区域，也就是正文段。上图中，这些指令被存储到了0x200-0x20c 的区域中：

   0x200 位置的 load 指令将地址 0x100 中的数据 11 导入寄存器 R0；

   0x204 位置的 load 指令将地址 0x104 中的数据 15 导入寄存器 R1；

   0x208 位置的 add 指令将寄存器 R0 和 R1 中的值相加，存入寄存器 R2；

   0x20c 位置的 store 指令将寄存器 R2 中的值存回数据区域中的 0x1108 位置。



3. 执行时候，PC指针先指向0x200位置，然后依次执行这4条指令





##### 1、指令

load 指令将内存中的数据导入寄存器，我们写成了 16 进制：0x8c000100，拆分成二进制就是：

![image-20210703223804826](typora-user-images/image-20210703223804826.png)

最左边的 6 位，叫作操作码，英文是 OpCode，100011 代表 load 指令；

中间的 4 位 0000是寄存器的编号，这里代表寄存器 R0；

后面的 22 位代表要读取的地址，也就是 0x100。



add 指令，16 进制表示是 0x08048000，换算成二进制就是：

![image-20210703223859757](typora-user-images/image-20210703223859757.png)

最左边的 6 位是指令编码，代表指令 add；

紧接着的 4 位 0000 代表寄存器 R0；

然后再接着的 4 位 0001 代表寄存器 R1；

再接着的 4 位 0010 代表寄存器 R2；

最后剩下的 14 位没有被使用。



构造指令的过程，叫做指令的编码，通常由编译器完成；解析指令的过程，叫做指令的解码，由CPU完成，

CPU内部有一个循环：**CPU 的指令周期**

1. 首先 CPU 通过 PC 指针读取对应内存地址的指令，我们将这个步骤叫作 Fetch，就是获取的意思。

2. CPU 对指令进行解码，我们将这个部分叫作 Decode。

3. CPU 执行指令，我们将这个部分叫作 Execution。

4. CPU 将结果存回寄存器或者将寄存器存入内存，我们将这个步骤叫作 Store。

![image (typora-user-images/Ciqc1F9fMKiAZhMVAABIVEePzcA916.png).png](https://s0.lgstatic.com/i/image/M00/4E/DF/Ciqc1F9fMKiAZhMVAABIVEePzcA916.png)



##### （2）指令类型

不同类型的指令、参数个数、每个参数的位宽，都不一样，而参数可以是以下三种类型：

- 寄存器
- 内存地址
- 数值



从功能角度划分，指令分成5类：

- I/O 类型的指令，比如处理和内存间数据交换的指令 store/load 等；再比如将一个内存地址的数据转移到另一个内存地址的 mov 指令。

- 计算类型的指令，最多只能处理两个寄存器，比如加减乘除、位运算、比较大小等。

- 跳转类型的指令，用处就是修改 PC 指针。比如编程中大家经常会遇到需要条件判断+跳转的逻辑，比如 if-else，swtich-case、函数调用等。

- 信号类型的指令，比如发送中断的指令 trap。

- 闲置 CPU 的指令 nop，一般 CPU 都有这样一条指令，执行后 CPU 会空转一个周期。



指令还有一个分法，寻址模式，比如同样是求和指令，可能会有2个版本：

- 将两个寄存器的值相加的 add 指令。

- 将一个寄存器和一个整数相加的 addi 指令。



另外，同样是加载内存中的数据到寄存器的 load 指令也有不同的寻址模式：

- 比如直接加载一个内存地址中的数据到寄存器的指令la，叫作直接寻址。

- 直接将一个数值导入寄存器的指令li，叫作寄存器寻址。

- 将一个寄存器中的数值作为地址，然后再去加载这个地址中数据的指令lw，叫作间接寻址。



64 位和 32 位比较有哪些优势？

1. 如果说的是 64 位宽 CPU，那么有 2 个优势。

优势 1：64 位 CPU 可以执行更大数字的运算，这个优势在普通应用上不明显，但是对于数值计算较多的应用就非常明显。

优势 2：64 位 CPU 可以寻址更大的内存空间

2. 如果 32 位/64 位说的是程序，那么说的是指令是 64 位还是 32 位的。32 位指令在 64 位机器上执行，困难不大，可以兼容。 如果是 64 位指令，在 32 位机器上执行就困难了。因为 32 位指令在 64 位机器执行的时候，需要的是一套兼容机制；但是 64 位指令在 32 位机器上执行，32 位的寄存器都存不下指令的参数。

3. 操作系统也是一种程序，如果是 64 位操作系统，也就是操作系统中程序的指令都是 64 位指令，因此不能安装在 32 位机器上。

































