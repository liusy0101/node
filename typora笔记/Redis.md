[toc]



# 1、Redis集群模式



## （1）主从模式

**主从复制原理：**（旧版）

- 从服务器连接主服务器，发送SYNC命令； 
- 主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令； 
- 主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令； 
- 从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； 
- 主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； 
- 从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；（**从服务器初始化完成**）
- 主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令（**从服务器初始化完成后的操作**）

 ![img](typora-user-images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NlbGVjdGdvb2Rib3k=,size_16,color_FFFFFF,t_70) 



**主从复制优缺点：**

**优点：**

- 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离
- 为了分载Master的读操作压力，Slave服务器可以为客户端提供只读操作的服务，写服务仍然必须由Master来完成
- Slave同样可以接受其它Slaves的连接和同步请求，这样可以有效的分载Master的同步压力。
- Master Server是以非阻塞的方式为Slaves提供服务。所以在Master-Slave同步期间，客户端仍然可以提交查询或修改请求。
- Slave Server同样是以非阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，Redis则返回同步之前的数据

**缺点：**

- Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。
- 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。
- Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。





**新版本：**

使用PSYNC命令代替SYNC命令

PSYNC命令具有**完整重同步**和**部分重同步**这两种模式：

1、完整重同步

​	用于处理初次复制情况，执行步骤跟SYNC命令步骤基本一样，都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步

2、部分重同步

​	处理断线后重复制情况，当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可将断开期间执行的写命令发送给从服务器，从服务器只要执行这些命令即可完成与主服务器的同步。





**部分重同步：**

由以下三部分构成：

- 主服务器的复制偏移量和从服务器的复制偏移量
- 主服务器的复制积压缓冲区
- 服务器的运行ID



（1）复制偏移量

执行复制的双方----主从服务器分别维护一个复制偏移量：

- 主服务器每次向从服务器传播N个字节数据，就将自身偏移量加上N
- 从服务器每次收到主服务器传来的N个字节，就将自身偏移量加上N

![1631844587790](typora-user-images/1631844587790.png)



![1631844598863](typora-user-images/1631844598863.png)

当主从偏移量不一致时，就说明不同步





（2）复制积压缓冲区

由主服务器维护的一个固定长度、先进先出（FIFO）队列，默认大小为1MB

当主服务器进行命令传播时，不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里

![1631844781440](typora-user-images/1631844781440.png)



所以，主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量。

![1631844858191](typora-user-images/1631844858191.png)

当从服务器重连主服务器时，从服务器会通过PSYNC命令将自身的复制偏移量offset发送给主服务器，主服务器根据这个复制偏移量决定对从服务器执行哪种同步操作：

- 如果offset偏移量之后的数据仍然存在于复制积压缓冲区里面，那么主服务器将对从服务器执行部分重同步操作。
- 如果offset偏移量之后的数据以及不存在于复制积压缓冲区里，那么主服务器将对从服务器执行完全重同步。



（3）服务器运行ID

每个Redis服务器，都有运行ID，启动时自动生成

当从服务器对主服务器进行初次复制时，从服务器收到主服务器的运行ID并保存起来

当从服务器断线重连后，将校验主服务器ID是否还是原来的

如果是，则可以执行部分重同步，反之，则执行完全重同步





**PSYNC命令步骤：**

![1631845298067](typora-user-images/1631845298067.png)



- 如果是首次连主服务器，或者之前执行过SLAVE no one命令，那么从服务器在开始一次新的复制时将向主服务器发送 `PSYNC ? -1`命令，主动请求进行完全重同步
- 如果已复制过某个主服，那么从服务器在开始一次新的复制时将向主服务器发送`PSYNC <runid> <offset>`命令，runid是上一次复制的主服务器运行ID，而offset则是从服务器当前的复制偏移量
- 如果主服务器返回`+FULLRESYNC <runid> <offset>` ，表示主服务器将于从服务器执行完整重同步，runid是当前主服务器的运行id，offset是当前主服务器的复制偏移量，从服务器将这个偏移量作为初始偏移量。
- 如果主服返回`+CONTINUE`，表示主服将与从服执行部分重同步
- 如果主服返回`-ERR`，表示主服版本低于2.8，识别不了PSYNC命令，主服将发送SYNC命令进行完整重同步。



























## （2）哨兵模式

 （哨兵）是Redis的高可用性解决方案：由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器。 

 ![img](typora-user-images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV10L3NlbGVjdGdvb2Rib3k=,size_16,color_FFFFFF,t_70) 

**哨兵的工作方式：**

- 每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程发送一个 PING 命令。
- 如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）
- 如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认Master主服务器的确进入了主观下线状态
- 当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认Master主服务器进入了主观下线状态（SDOWN）， 则Master主服务器会被标记为客观下线（ODOWN）
- 在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。
- 当Master主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。
- 若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。



**哨兵模式的优缺点**

**优点：**

- 哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都具有。
- 主从可以自动切换，系统更健壮，可用性更高。

**缺点：**

- Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。



选举sentinel领导者 使用的raft算法(https://raft.github.io)，大致思路：

1. 每个做主观下线的sentinel节点像其他sentinel节点发送命令，要求将自己设置为领导者
2. 接收到的sentinel可以同意或者拒绝

3. 如果该sentinel节点发现自己的票数已经超过半数并且超过了quorum
4. 如果此过程选举出了多个领导者，那么将等待一段时重新进行选举



主节点选举：选举出可以代替主节点的slave从节点

- 1、选择健康状态从节点（排除主观下线、断线），排除5秒钟没有心跳的、排除主节点失联超过10*down-after-millisecends
- 2、选择slave-priority高的从节点优先级列表
- 4、选择偏移量大的
- 5、选择runid小的



进行故障转移

- 1、sentinel的领导者从slave中选举出合适的从节点进行故障转移
- 2、对选取的slave执行slave of no one
- 3、更新应用程序端的链接到新的主节点

- 4、对其他从节点变更master为新的节点

- 5、修复原来的master并将其设置为新master的slave



## （3）Cluster模式

Redis-Cluster采用无中心结构,它的特点如下：

- 所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。
- 节点的fail是通过集群中超过半数的节点检测失效时才生效。
- 客户端与redis节点直连,不需要中间代理层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。

**工作方式：**

在redis的每一个节点上，都有这么两个东西，一个是插槽（slot），它的的取值范围是：0-16383。还有一个就是cluster，可以理解为是一个集群管理的插件。当我们的存取的key到达的时候，redis会根据crc16的算法得出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。

为了保证高可用，redis-cluster集群引入了主从模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点。当其它主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。如果主节点A和它的从节点A1都宕机了，那么该集群就无法再提供服务了。





**数据迁移方式**

Redis使用了哈希槽的概念，并没有使用一致性hash。

数据迁移是slot（槽）和key的迁移，此功能可实现平滑的扩容和缩容。

 现在要将Master A节点中编号为1、2、3的slot迁移到Master B节点中，在slot迁移的中间状态下，slot 1、2、3在Master A节点的状态表现为MIGRATING（迁移）,在Master B节点的状态表现为IMPORTING（入口）。 

 ![img](typora-user-images/20180103174740149) 

**此时并不会刷新node的映射关系**



**IMPORTING状态**

被迁移slot在目标Master B节点中出现的一种状态 ，准备迁移slot从Mater A到Master B的时候，被迁移slot的状态首先变为IMPORTING状态。 



**键空间迁移**

 键空间迁移是指当满足了slot迁移前提的情况下，通过相关命令将slot 1、2、3中的键空间从Master A节点转移到Master B节点。此时刷新node的映射关系。 

 ![img](typora-user-images/20180103174824673) 



# 2、Redis持久化方式

Redis提供了两种持久化方式，分别是RDB和AOF。



**一、RDB（保存数据库键对值）**

（1）redis默认开启了RDB持久化方式

```
#下面这一行取消注释，下面三行注释掉，就是关闭RDB
#save ""
#下面三行是开启RDB持久化方式
save 900 1
save 300 10
save 60 10000
```

开启之后，会生成一个dump.rdb文件，这个就是数据落在磁盘上的实际存储文件。下面是对这三行配置的解读。

```
#每900秒内，数据库至少有1次修改就进行保存 
save 900 1
#每300 秒内，数据库至少有10次修改就进行保存
save 300 10
#每60 秒内，数据库至少有10000次修改就进行保存
save 60 10000
```

（2）开启RDB持久化之后，数据库启动的时候就会先加载dump.rdb文件进内存 ，这个过程是阻塞的

![图片](https://mmbiz.qpic.cn/mmbiz_png/1WZDcbq4okjDfwMaBavMQicokjSc4pu41WkzFgMeibb1riaJXUZGA6MAuykFjEjyqK06CyImT43pdKu8UUVQdnxuA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

（3）执行***SAVE***或***BGSAVE***命令可以触发RDB方式数据落盘保存

SAVE命令是阻塞的，BGSAVE命令是非阻塞的，其实上述的几秒内有至少几次修改就保存的后台也是执行的BGSAVE命令。

![图片](https://mmbiz.qpic.cn/mmbiz_png/1WZDcbq4okjDfwMaBavMQicokjSc4pu41sqLOL9F8gibJ6MpzqX9e8XxjLLX478N6vRpuyWicLiaDBstUOZt2CSwIg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)





**二、AOF（Append Only File，保存数据库执行过的命令）**

（1）开启AOF持久化非常简单，配置一下两个配置项就行

```
#开启aof命令
appendonly yes
#aof文件名称
appendfilename "appendonly.aof"
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/1WZDcbq4okjDfwMaBavMQicokjSc4pu41viadNwU47ozVa1amUcW6iazxyFmzXgMUia8uQ6tuhCwNyaPZPDdPCaY7w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

（2）开启AOF之后，redis启动会去加载aof文件，但是不会去加载rdb文件，因为aof文件的更新速度比rdb文件快，所以redis会优先加载aof文件，只有当aof没开启时，才会去加载rdb文件。

![图片](https://mmbiz.qpic.cn/mmbiz_png/1WZDcbq4okjDfwMaBavMQicokjSc4pu41AibcpPQOKkbySv9TXq0cg2UBVribMZopB3rW1hIYAiclAIEiaMWibibdNqNA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

![图片](https://mmbiz.qpic.cn/mmbiz_png/1WZDcbq4okjDfwMaBavMQicokjSc4pu414wv7GzZWTfjHp0qSupzwOnqiaUbic5ic0icR1he2bCZ444aV01sZmJpSQw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



# 3、分布式锁



## （1）何为分布式锁

在分布式模型下，数据只有一份，此时需要利用锁的技术控制某一时刻修改数据的进程数。与单机模式下的锁不仅需要保证进程可见，还需要考虑进程与锁之间的网络问题。



## （2）需要什么样的分布式锁？

- 可保证在分布式部署的应用集群中，同一个方法在同一时间只能被一台机器上的一个线程执行
- 可重入锁
- 公平锁
- 阻塞锁
- 高可用的获取锁和释放锁，并且性能要好



## （3）基于数据库做分布式锁

### 1、基于乐观锁

利用表主键唯一做分布式锁，需要获取锁的线程同时插入同一条数据，插入成功的就获取了锁

**问题：**

- 强依赖数据库可用性，数据库是单点的话会导致系统不可用
- 没有失效时间，一旦解锁操作失败，会导致数据一直在数据库中，其它线程无法获取锁
- 锁只能是非阻塞的，因为数据的insert操作，插入失败会直接报错，没获取到锁的进程并不会进入排队队列，想获取锁只能再次触发获取锁的操作。
- 非重入，同一线程在没释放锁之前无法再次获取锁
- 非公平的
- 在 MySQL 数据库中采用主键冲突防重，大并发情况下可能会造成锁表现象



**解决方法：**

- 数据库进行主备同步，主节点挂掉后备用节点顶上
- 定时清除数据
- 非阻塞，用while循环，直至获取锁
- 记录拥有锁的主机信息和线程信息，当线程相同可直接获取锁
- 可用另一张表记录等待锁的线程，根据创建时间排序，只允许最先创建的线程获取锁



### 2、基于悲观锁

基于数据库排他锁做分布式锁 在查询语句后面增加for update，数据库会在查询过程中给数据库表增加排他锁。

可以认为获得排他锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，通过connection.commit()操作来释放锁。

 这种方法可以有效的解决上面提到的无法释放锁和阻塞锁的问题。 阻塞锁 for update语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。 锁定之后服务宕机，无法释放？使用这种方式，服务宕机之后数据库会自己把锁释放掉。

无法直接解决数据库单点和可重入的问题。



虽然我们对方法字段名使用了唯一索引，并且显示使用 for update 来使用行级锁。但是，MySQL 会对查询进行优化，即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。如果发生这种情况就悲剧了。。。 还有一个问题，就是我们要使用排他锁来进行分布式锁的 lock，那么一个排他锁长时间不提交，就会占用数据库连接。一旦类似的连接变得多了，就可能把数据库连接池撑爆。



## （4）基于Redis做分布式锁

### 1、setnx()、expire()方法做分布式锁

setnx(key,value)，此方法是原子的，如果key不存在，则设置当前key成功，返回1；如果当前key已经存在，则设置当前key失败，返回0，expire()方法用来设置过期时间

setnx命令不能设置key的超时时间，只能通过expire来对key设置。

**步骤：**

- setnx(lockkey, 1) 如果返回 0，则说明占位失败；如果返回 1，则说明占位成功
- expire() 命令对 lockkey 设置超时时间，为的是避免死锁问题。
- 执行完业务代码后，可以通过 delete 命令删除 key



**问题：**

setnx执行成功后，在expire命令执行成功前，发生了宕机，那么会出现死锁的问题。



### 2、利用setnx、get、getset方法做

getset(key,new_value)，是原子的，对key设置new_value，并且返回key原来的旧值，如果key不存在，就返回null，此时key就被设置位new_value。

**步骤：**

- setnx(lockkey, 当前时间+过期超时时间)，如果返回 1，则获取锁成功；如果返回 0 则没有获取到锁，转向2。
- get(lockkey) 获取值 oldExpireTime ，并将这个 value 值与当前的系统时间进行比较，如果小于当前系统时间，则认为这个锁已经超时，可以允许别的请求重新获取，转向 3。
- 计算 newExpireTime = 当前时间+过期超时时间，然后 getset(lockkey, newExpireTime) 会返回当前 lockkey的值currentExpireTime。
- 判断 currentExpireTime 与 oldExpireTime 是否相等，如果相等，说明当前 getset 设置成功，获取到了锁。如果不相等，说明这个锁又被别的请求获取走了，那么当前请求可以直接返回失败，或者继续重试。
- 在获取到锁之后，当前线程可以开始自己的业务处理，当处理完毕后，比较自己的处理时间和对于锁设置的超时时间，如果小于锁设置的超时时间，则直接执行 delete 释放锁；如果大于锁设置的超时时间，则不需要再锁进行处理。



## （5）基于Zookeeper做分布式锁

**zk** **基本锁 原理：**

利用临时节点与 watch 机制。每个锁占用一个普通节点 /lock，当需要获取锁时在 /lock 目录下创建一个临时节点，创建成功则表示获取锁成功，失败则 watch/lock 节点，有删除操作后再去争锁。临时节点好处在于当进程挂掉后能自动上锁的节点自动删除即取消锁。 **缺点：**所有取锁失败的进程都监听父节点，很容易发生羊群效应，即当释放锁后所有等待进程一起来创建节点，并发量很大。

**zk** **锁优化 原理：**

上锁改为创建临时有序节点，每个上锁的节点均能创建节点成功，只是其序号不同。只有序号最小的可以拥有锁，如果这个节点序号不是最小的则 watch 序号比本身小的前一个节点 (公平锁)。

 **步骤：**

- 在 /lock 节点下创建一个有序临时节点 (EPHEMERAL_SEQUENTIAL)。
- 判断创建的节点序号是否最小，如果是最小则获取锁成功。不是则取锁失败，然后 watch 序号比本身小的前一个节点。（避免很多线程watch同一个node，导致羊群效应）
- 当取锁失败，设置 watch 后则等待 watch 事件到来后，再次判断是否序号最小。
- 取锁成功则执行代码，最后释放锁（删除该节点）。

**优缺点** 

优点： 有效的解决单点问题，不可重入问题，非阻塞问题以及锁无法释放的问题。实现起来较为简单。

缺点： 性能上可能并没有缓存服务那么高，因为每次在创建锁和释放锁的过程中，都要动态创建、销毁临时节点来实现锁功能。ZK 中创建和删除节点只能通过 Leader 服务器来执行，然后将数据同步到所有的 Follower 机器上。还

需要对 ZK的原理有所了解



# 4、Redis为什么这么快

- 纯内存操作
- 单线程操作，避免了频繁的上下文切换
- 采用了非阻塞的IO多路复用机制



Redis单线程仅是指负责存取这一块的线程只有一个，而不是redis只有一个进程

![image-20210328231020661](typora-user-images/image-20210328231020661.png)





# 5、redis的过期策略以及内存淘汰机制



## **（1）三种删除策略：**



**定时删除：**

设置键过期时间同时，创建定时器，让定时器在键过期时间来临时，立即执行删除操作。

对内存友好，对CPU不友好。在内存不紧张但是CPU紧张的情况下会造成性能瓶颈。



**惰性删除：**

在访问某个键的时候，检查是否已过期，如果过期就删除，否则返回。

对CPU友好，对内存不友好。如果有一些key过期了，但是不会没有访问，那么会一直待在内存中，造成内存泄露。



**定期删除：**

每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于删除多少，执行多长时间，检查多少数据库，由算法决定。

通过限制删除操作执行的时长和频率来减少对CPU时间的影响。











数据设置了过期时间，时间到了内存占用为什么还高？

**redis采用的是定期删除+惰性删除策略**



**为什么不是定时删除？**

用一个定时器负责监视key，过期自动删除，虽然内存及时释放，但是十分消耗CPU资源，在大并发请求下，CPU要将时间应用在处理请求，而不是删除key，所以没有采取定时删除。



**定期删除+惰性删除：**

定期删除，redis默认每隔100ms检查，是否有过期的key，有就删除。

redis并不是每隔100ms将所有的key检查一次，而是随机抽取进行检查，如果每隔100ms就需要检查一次，那么redis会卡死。

此时惰性删除就有了，在获取某个key的时候，redis会检查是否过期，如果过期就删除。

如果定期+惰性都没删除key，那么就需要采用内存淘汰机制。



**内存淘汰机制：**

（1）noeviction：内存不够写入失败

（2）allkeys-lru：内存不足，在所有key中移除最近最少使用的key

（3）allkeys-random：内存不足时，所有key中随机删除

（4）volatile-lru：内存不足时，在设置了过期时间的key中移除最近最少使用的key

（5）volatile-random：内存不足时，在设置了过期时间的key中随机移除

（6）volatile-ttl：内存不足时，在设置了过期时间的key中删除最先过期的key







## （2）AOF、RDB和复制功能对过期键的处理



### 1、RDB

如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：

（1）如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的被载入，过期的忽略。

（2）如果服务器以从服务器模式运行，不论是否过期都会被载入。





### 2、AOF

当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没被惰性删除或定期删除，那么AOF文件不会因为这个过期键而产生任何影响。

当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加一条DEL命令，显示记录该键已被删除。



### 3、AOF重写

AOF重写过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。



### 4、复制

当服务器运行在复制模式下，从服务器的过期键删除动作由主服务器控制。

- 主服务器在删除一个过期键后，显示向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。
- 从服务器在执行客户端发送的读命令时，即使碰到过期键也不会删除，而是像处理未过期键一样
- 从服务器只有在接到主服务器发来的DEL命令后，才会删除过期键。





























# 6、缓存穿透、击穿、雪崩

## （1）**缓存穿透**

概念访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉。

**解决方案**：

采用布隆过滤器，使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤；

访问key未在DB查询到值，也将空值写进缓存，但可以设置较短过期时间。

## （2）**缓存雪崩**

大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。

**解决方案**

可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效；

采用限流算法，限制流量；

采用分布式锁，加锁访问。

## （3）缓存击穿

热门数据突然失效，大量请求到服务器数据库中



**解决方案：**

热点数据永不过期



# 7、渐进式ReHash

![1631587519272](typora-user-images/1631587519272.png)

ht属性是一个包含两个项的数组，数组中的每个项都是一个哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]进行rehash时使用

**原因：**

rehash过程不是一步完成的，分多次、渐进式完成。如果哈希表中保存着数量巨大的键对值时，如果一次进行rehash，很可能会导致服务器宕机。



**步骤：**

- 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表
- 维持索引计数器变量rehashidx，并将它的值设置为0，表示rehash开始
- 每次对字典执行增删改查时，将ht[0]的rehashidx索引上的所有键值对rehash到ht[1]，将rehashidx值+1。 
- 当ht[0]的所有键值对都被rehash到ht[1]中，程序将rehashidx的值设置为-1，表示rehash操作完成



注：渐进式rehash的好处在于它采取分为而治的方式，将rehash键值对的计算均摊到每个字典增删改查操作，避免了集中式rehash的庞大计算量。



在进行渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以字典的删除、查抄、更新等操作会在两个哈希表上进行。例如，查找一个键，会先在ht[0]里面先找，如果没找到，就会继续到ht[1]里面进行查找。

在此过程中，新添加的字典键值对会保存在ht[1]里面，而ht[0]不再进行任何添加操作。





# 8、BitMap

## （1）基本思想

32位机器上，对于一个整型数，比如int a=1 在内存中需要占用32bit位，这是为了方便计算机运算，但在内存中属于一种浪费，因此可用对应的32bit位对应存储十进制的0-31个数字，这就是bit-map的基本思想。

利用bitmap可处理大量数据的排序、查询及去重，做交集并集运算也有极大的便利。



## （2）快速排序

假设我们要对0-7内的5个元素(4,7,2,5,3)排序（这里假设这些元素没有重复）,我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），首先我们开辟1Byte的空间，将这些空间的所有Bit位都置为0，然后再将对应下标的位置设置为1，然后遍历bit区域，将1的下标输出，就是排序了，时间复杂度是O(n)



## （3）快速去重

一个数字的状态只有三种，分别为不存在，只有一个，有重复。因此，我们只需要2bits就可以对一个数字的状态进行存储了，假设我们设定一个数字不存在为00，存在一次01，存在两次及其以上为11。那我们大概需要存储空间几十兆左右。 接下来的任务就是遍历一次这2.5亿个数字，如果对应的状态位为00，则将其变为01；如果对应的状态位为01，则将其变为11；如果为11，,对应的转态位保持不变。 最后，我们将状态位为01的进行统计，就得到了不重复的数字个数，时间复杂度为O(n)。



## （4）快速查询

如何快速判断一个数字是够存在于上述的2.5亿个数字集合中。 同之前一样，首先我们先对所有的数字进行一次遍历，然后将相应的转态位改为1。遍历完以后就是查询，由于我们的Bit-map采取的是连续存储（整型数组形式，一个数组元素对应32bits），我们实际上是采用了一种分桶的思想。一个数组元素可以存储32个状态位，那将待查询的数字除以32，定位到对应的数组元素（桶），然后再求余 （%32），就可以定位到相应的状态位。如果为1，则代表改数字存在；否则，该数字不存在。



# 9、布隆过滤器

当一个元素被加入集合中时,通过k个散列函数将这个元素映射成一个位数组中的k个点,并将这k个点全部置为1.

有一定的误判率--在判断一个元素是否属于某个集合时,有可能会把不属于这个集合的元素误判为属于这个集合.

因此,它不适合那些"零误判"的应用场合.在能容忍低误判的应用场景下,布隆过滤器通过极少的误判换区了存储空间的极大节省. 



Bloom Filter使用k个相互独立的哈希函数（Hash Function），它们分别将集合中的每个元素映射到{1,…,m}的范围中。对任意一个元素x，第i个哈希函数映射的位置hi(x)就会被置为1（1≤i≤k）。注：如果一个位置多次被置为1，那么只有第一次会起作用，后面几次将没有任何效果。 在判断y是否属于这个集合时，对y应用k次哈希函数，若所有hi(y)的位置都是1（1≤i≤k），就认为y是集合中的元素，否则就认为y不是集合中的元素。





# 10、为什么有序集合需要同时用到字典和跳跃表



可以单独使用字典或者跳跃表的其中一种数据结构来实现，但是性能上对比起同时使用会有所降低。

比如，只使用字典，可以以O(1)时间复杂度查找成员，但是范围性操作需要先进行排序，时间复杂度高，O(nlogn)以及O(n)内存空间。

只使用跳跃表，查找复杂度会是O(logn)

![1631589306425](typora-user-images/1631589306425.png)







- 服务器在执行命令之前，会先检查给定键的类型能否执行指定的命令，而检查一个键的类型就是检查键的值对象的类型。
- Redis的对象系统带有引用计数实现的内存回收机制，当一个对象不再被使用时，该对象所占用的内存就会被自动释放
- Redis会共享值为0到9999的字符串对象





















































