[toc]



# 分布式

![image-20200915225949913](.\typora-user-images\image-20200915225949913.png)

## 1、分布式环境的特点



1、分布性

2、并发性：程序运行过程中，并发性操作是很常见的。比如同一个分布式系统中的多个节点，同时访问一个共享资源。数据库、分布式存储

3、无序性：进程之间的消息通信，会出现顺序不一致问题

 

## 2、分布式环境下面临的问题

1、网络通信：网络本身的不可靠性，因此会涉及到一些网络通信问题

2、网络分区(脑裂)：当网络发生异常导致分布式系统中部分节点之间的网络延时不断增大，最终导致组成分布式架构的所有节点，只有部分节点能够正常通信

3、三态：在分布式架构里面，除了成功、失败、超时

4、分布式事务：ACID(原子性、一致性、隔离性、持久性)

 

## 3、中心化和去中心化

冷备或者热备

 

分布式架构里面，很多的架构思想采用的是：当集群发生故障的时候，集群中的人群会自动“选举”出一个新的领导。

最典型的是： zookeeper / etcd

 

## 4、经典的CAP/BASE理论

### （1）CAP

一致性（Consistency）: 所有节点上的数据，时刻保持一致

可用性（Availability）：每个请求都能够收到一个响应，无论响应成功或者失败

分区容错（Partition-tolerance）：表示系统出现脑裂以后，可能导致某些server与集群中的其他机器失去联系

CP  / AP

 

CAP理论仅适用于原子读写的Nosql场景，不适用于数据库系统



### （2）BASE

基于CAP理论，CAP理论并不适用于数据库事务（因为更新一些错误的数据而导致数据出现紊乱，无论什么样的数据库高可用方案都是徒劳） ，虽然XA事务可以保证数据库在分布式系统下的ACID特性，但是会带来性能方面的影响；

 

eBay尝试了一种完全不同的套路，放宽了对事务ACID的要求。提出了BASE理论

**Basically available  ：** 数据库采用分片模式， 把100W的用户数据分布在5个实例上。如果破坏了其中一个实例，仍然可以保证80%的用户可用

**soft-state：**  在基于client-server模式的系统中，server端是否有状态，决定了系统是否具备良好的水平扩展、负载均衡、故障恢复等特性。

Server端承诺会维护client端状态数据，这个状态仅仅维持一小段时间, 这段时间以后，server端就会丢弃这个状态，恢复正常状态

**Eventually consistent：**数据的最终一致性



## 5、分布式事务解决方案

### 1、分布式事务产生背景

#### （1）数据库分库分表

#### （2）服务soa化

#### （3）事务执行情况协调

在分布式系统中，每一个机器节点虽然都能明确的知道自己执行的事务是成功还是失败，但是却无法知道其他分布式节点的事务执行情况。因此，当一个事务要跨越多个分布式节点的时候（比如，下单流程，下单系统和库存系统可能就是分别部署在不同的分布式节点中），为了保证该事务可以满足ACID，就要引入一个协调者（Cooradinator）。其他的节点被称为参与者（Participant）。协调者负责调度参与者的行为，并最终决定这些参与者是否要把事务进行提交。

#### （4）数据库事务需满足条件：ACID

Atomic（原子性）：事务操作必须是原子性的，要么成功，要么失败

Consistent（一致性）：事务完成后，必须使所有数据都保持一致状态

Isolation（隔离性）：并发事务所做的修改必须和其他事务所做的修改是隔离的，也就是只能访问事务前和事务后的状态，不能访问事务操作时的状态。

Duration（持久性）：事务完成之后，对系统的影响是永久的。

#### （5）MySQL事务处理过程

1. 记录redo和undo log文件，确保日志在磁盘上的持久化

2. 更新数据记录

3. 提交事务 ，redo 写入commit记录

### 2、X/OpenDTP事务模型

X/Open Distributed Transaction Processing Reference Model 
X/Open是一个组织机构，定义出的一套分布式事务标准， 定义了规范的API接口

2PC（two -phase-commit）, 用来保证分布式事务的完整性
J2EE 遵循了X/open DTP规范，设计并实现了java里面的分布式事务编程接口规范-JTA
XA是X/Open DTP定义的中间件与数据库之间的接口规范。 XA接口函数由数据库厂商提供

X/OpenDTP 角色
AP application           
RM resouces manager   资源管理器。 数据库
TM transaction manager  事务管理器，事务协调者



### 3、2PC（two -phase-commit）

#### （1）阶段一：提交事务请求（投票）

1、TM向所有的AP发送事务内容，询问是否可以执行事务的提交操作，并等待各个AP的响应

2、执行事务

​		各个AP节点执行事务操作，将undo和redo信息记录到事务日志中，尽量把提交过程中所消耗时间的操作和准备都提前完成后确保后续事务提交的成功率

3.各个AP向TM反馈事务询问的响应

​		各个AP成功执行了事务操作，那么反馈给TM yes的response；如果AP没有成功执行事务，就反馈TM no的response



#### （2）阶段二：执行事务提交

1、执行提交事务

![image-20200414231425816](.\typora-user-images\image-20200414231425816.png)

假设一个事务的提交过程总共需要30s， 其中prepare操作需要28（事务日志落地磁盘及各种io操作），而真正commit只需要2s，那么，commit阶段发生错误的概率和prepare相比， 2/28 (<10%) .只要第一个阶段成功，那么commit阶段出现失败的概率就非常小，大大增加了分布式事务的成功概率

2、中断事务提交

![image-20200414231511468](.\typora-user-images\image-20200414231511468.png)



#### （3）2pc存在的问题

1、数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。

2、同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态

3、二阶段无法解决的问题：协调者在发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交

4、单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去



### 4、3PC(three phase commit)

#### 1、阶段一：canCommit

先询问是否可以执行commit，如果有一台机器返回no，就停止事务

#### 2、阶段二：preCommit

各个AP节点执行事务操作，将undo和redo信息记录到事务日志中，尽量把提交过程中所消耗时间的操作和准备都提前完成后确保后续事务提交的成功率

#### 3、阶段三：doCommit

各个AP成功执行了事务操作，那么反馈给TM yes的response；如果AP没有成功执行事务，就反馈TM no的response



改进点

1、增加了超时机制

2、第二阶段，如果协调者超时没有接受到参与者的反馈，则自动认为失败，发送abort命令

3、第三阶段，如果参与者超时没有接受到协调者的反馈，则自动认为成功开始提交事务（基于概率）



问题：

相对于2PC，3PC主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。



### 5、分布式事务的实现

1、JOTM(java open transaction manager)

2、Atomikos



### 6、XA/JTA

XA 就是 X/Open DTP 定义的事务管理器与资源管理器的接口规范（即接口函数），XA 接口函数由数据库厂商提供。
JTA是基于X/Open DTP模型开发的java transaction APi规范 

### 7、互联网的分布式事务解决方案

#### （1）业务接口整合，避免分布式事务

#### （2）最终一致性方案之ebay模式

它主要采用消息队列来辅助实现事务控制流程，方案的核心是将需要分布式处理的任务通过消息队列的方式来异步执行，如果事务失败，则可以发起人工重试的纠正流程。人工重试被更多的应用于支付场景，通过对账系统对事后问题进行处理。

#### （3）保证最终一致性的模式

1、查询模式

任何一个服务操作都提供一个查询接口，用来向外部输出操作执行的状态。服务操作的使用方可以通过接口得知服务操作执行的状态，然后根据不同状态做不同的处理操作
为了能够实现查询，每个服务操作都需要有唯一的流水号

2、补偿模式

有了查询模式，我们就能够得知操作所处的具体状态，如果整个操作处于不正常状态，我们需要修正操作中的出现问题的子操作。也许是要重新执行，或者取消已完成的操作。通过修复使得整个分布式系统达到最终一致。这个过程就是补偿模式
根据发起形式又分为
自动恢复：通过对发生失败操作的接口自动重试或者回滚已经完成的操作
通知运营：如果程序无法自动完成恢复，则通过运营人员手动进行补偿
通知技术：通过监控或者告警通知到技术人员，通过技术手段进行修复

#### （4）X/OpenDTP模型的支付宝的DTS架构

DTS(Distributed Transaction Service)框架是由支付宝在X/OpenDTP模型的基础上改进的一个设计，定义了类似2PC的标准两阶段接口，业务系统只需要实现对应的接口就可以使用DTS的事务功能。DTS最大的特点是放宽了数据库的强一致约束，保证了数据的最终一致性。

![image-20200414233304836](.\typora-user-images\image-20200414233304836.png)

**TCC分为三个阶段TRYING-CONFIRMING-CANCELING。每个阶段做不同的处理。**
TRYING、CONFIRMING、CANCELIING大致可以理解为SQL事务中的LOCK、COMMIT、ROLLBACK
TRYING 阶段主要是对业务系统做检测及资源预留 
CONFIRMING 阶段主要是对业务系统做确认提交，TRYING阶段执行成功并开始执行CONFIRMING阶段时，默认 CONFIRMING阶段是不会出错的。即：只要TRYING成功，CONFIRMING一定成功。 
CANCELING 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。 

**以上所有的操作需要满足幂等性，幂等性的实现方式可以是：** 
1、通过唯一键值做处理，即每次调用的时候传入唯一键值，通过唯一键值判断业务是否被操作，如果已被操作，则不再重复操作 
2、通过状态机处理，给业务数据设置状态，通过业务状态判断是否需要重复执行

**如何更通俗的理解TCC事务模型**
支付系统接收到会员的支付请求后，需要扣减会员账户余额、增加会员积分（暂时假设需要同步实现）增加商户账户余额
会员系统、商户系统、积分系统是独立的三个子系统，无法通过传统的事务方式进行处理。
TRYING阶段：我们需要做的就是会员资金账户的资金预留，即：冻结会员账户的金额（订单金额）
CONFIRMING阶段：我们需要做的就是会员积分账户增加积分余额，商户账户增加账户余额
CANCELING阶段：该阶段需要执行的就是解冻释放我们扣减的会员余额

#### （5）最大努力通知型

做过支付宝交易接口的同学都知道，我们一般会在支付宝的回调页面和接口里，解密参数，然后调用系统中更新交易状态相关的服务，将订单更新为付款成功。同时，只有当我们回调页面中输出了success字样或者标识业务处理成功相应状态码时，支付宝才会停止回调请求。否则，支付宝会每间隔一段时间后，再向客户方发起回调请求，直到输出成功标识为止。







