[toc]



# 操作系统



## 一、综述

### 1、简单命令

（1）修改密码 passwd

（2） 新建用户 useradd userName
 		 删除用户 userdel username

 添加的用户指定相应的group用户组
 useradd -g userName group

创建用户的时候，没有说加入哪个组，于是默认就会创建一个同名的组。


（3） 给用户设置密码 passwd password

通过命令创建的用户，其实是放在 /etc/passwd 文件里的
用户组的信息我们放在 /etc/group 文件

（4） 用户组
groupadd groupname　　添加用户组
groupdel groupname　　删除用户组

（5） 查看文件

ls -l 查看所有

如： drwxr-xr-x 6 root root 4096 Oct 20 2017 apt

文件权限

第一个字段剩下的 9 个字符是模式
rwx 表示“读（read）”“写（write）”“执行（execute）” - 表示没有权限

第二个字段是硬链接（hard link）数目

第三个字段是所属用户，第四个字段是所属组。第五个字段是文件的大小，第六个字段是文件被修改的日期，最后是文件名。

（6） 安装软件

CentOS 下面使用rpm -i jdk-XXX_linux-x64_bin.rpm进行安装

Ubuntu 下面使用dpkg -i jdk-XXX_linux-x64_bin.deb

其中 -i 就是 install 的意思。

或者 wget url地址 下载 软件安装文件

（7） 管道技术 |

rpm -qa | grep jdk

grep 表示 筛选搜索带关键词 jdk 的行，并且输出出来。grep 支持正则表达式。


不知道关键词，可以使用rpm -qa | more和rpm -qa | less这两个命令，它们可以将很长的结果分页展示出来

软件管家下载

软件管家，CentOS 下面是 yum，Ubuntu 下面是 apt-get。

例：
安装
yum install java-11-openjdk.x86_64
apt-get install openjdk-9-jdk

卸载
yum erase java-11-openjdk.x86_64
apt-get purge openjdk-9-jdk

软件管家

CentOS 来讲，配置文件在/etc/yum.repos.d/CentOS-Base.repo里
Ubuntu 来讲，配置文件在/etc/apt/sources.list里

（8） 解压

tar.gz tar vxzf xxx.tar 解压

（9） 编辑文件
 vi或者vim ： vim 文件名

i 意思是 insert。进入编辑模式，可以插入、删除字符

先按 esc
然后：wq 保存
然后 :q! 不保存



（10） 启动
一般进入文件bin下 或者指定目录 ./xxx 就可以启动 如：tomcat 启动 ./start

后台运行
nohup xxx & 表示当前启动的进程后台运行 如： nohup COMMAND &

指定进程日志输出
nohup command >out.file 2>&1 &。

这里面，“1”表示文件描述符 1，表示标准输出，“2”表示文件描述符 2，意思是标准错误输出，“2>&1”表示标准输出和错误输出合并了。合并到哪里去呢？到 out.file 里。
查看进程
启动后如何查看进程 ps -ef | grep jdk 查看 jdk的进程

杀进程
kill -9 pid ，pid可以通过 ps -ef | grep jdk 查看 jdk的进程号

（11） 关机重启
shutdown -h now是现在就关机
reboot就是重启。 





### 2、系统调用

#### （1）进程管理

创建进程的系统调用叫**fork**

在Linux中，要创建一个新的进程，需要一个老的进程调用fork来实现，其中老的进程叫**父进程**，新的进程叫**子进程**

 ![img](typora-user-images/f433f5d14e79612032ea625b44ac6178.jpeg) 

当父进程调用fork创建进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝了一份，连程序代码都是拷贝过去。

对于fork系统调用的返回值，如果当前进程是子进程，就返回0；如果当前进程是父进程，就返回子进程的进程号。这样就能通过返回值做判断，如果是父进程，接着做原来应该做的事情，如果是子进程，需要请求另一个系统调用execve来执行另一个程序。此时，子进程和父进程就彻底分开了，也就产生了一个分支（fork）。

 ![img](typora-user-images/e8ee83d78538bd43d3835662ded92e7f.jpeg) 



**对于操作系统来说，启动的时候先创建一个所有用户进程的“祖宗进程”。** 

 进程id为1的init进程是用户态所有进程的祖宗，进程id为2的kthread是内核态所有进程的祖宗 



有时，父进程需要知道子进程的运行情况，有个系统调用**waitpid** ，父进程可以调用它，将子进程的进程号作为参数传给它，这样父进程就知道字进程运行完没有，以及是否成功。



#### （2）内存管理

**在操作系统中，每个进程都有自己的内存，互相之间不干扰，有独立的进程内存空间。**

对于进程的内存空间来说，放程序代码的部分称为**代码段**

放进程运行中产生数据的部分，称为**数据段**，其中局部变量的部分，在当前函数执行的时候起作用，当进入另一个函数时，这个变量就释放了，也有动态分配的，会保存较长时间，指明才销毁的，这部分称为**堆**；

进程在写入数据时，发现没有对应的物理内存，会触发一个中断，现分配物理内存。

 两个在堆里面分配内存的系统调用，brk和mmap 

 当分配的内存数量比较小的时候，使用 brk，会和原来的堆的数据连在一起 

 当分配的内存数量比较大的时候，使用 mmap，会重新划分一块区域， 



#### （3）文件管理

 对于文件的操作，下面这六个系统调用是最重要的： 

- 对于已经有的文件，可以使用open打开这个文件，close关闭这个文件；
- 对于没有的文件，可以使用creat创建文件；
- 打开文件以后，可以使用lseek跳到文件的某个位置；
- 可以对文件的内容进行读写，读的系统调用是read，写是write。 

**Linux中，一切皆文件：**

-  启动一个进程，需要一个程序文件，这是一个二进制文件。
- 启动的时候，要加载一些配置文件，例如 yml、properties 等，这是文本文件；启动之后会打印一些日志，如果写到硬盘上，也是文本文件。
- 但是如果我想把日志打印到交互控制台上，在命令行上唰唰地打印出来，这其实也是一个文件，是标准输出 stdout 文件。
- 这个进程的输出可以作为另一个进程的输入，这种方式称为管道，管道也是一个文件。
- 进程可以通过网络和其他进程进行通信，建立的 Socket，也是一个文件。
- 进程需要访问外部设备，设备也是一个文件。
- 文件都被存储在文件夹里面，其实文件夹也是一个文件。
- 进程运行起来，要想看到进程运行的情况，会在 /proc 下面有对应的进程号，还是一系列文件。 



每个文件，Linux都会分配一个**文件描述符**，这是一个整数。通过这个文件描述符，可使用系统调用，查看或干预进程运行的方方面面。



#### （4）信号处理

 经常遇到的信号有以下几种：

- 在执行一个程序的时候，在键盘输入“CTRL+C”，这就是中断的信号，正在执行的命令就会中止退出；
- 如果非法访问内存，例如你跑到别人的会议室，可能会看到不该看的东西；
- 硬件故障，设备出了问题，当然要通知项目组；用户进程通过kill函数，将一个用户信号发送给另一个进程。 

 像 SIGKILL（用于终止一个进程的信号）和 SIGSTOP（用于中止一个进程的信号）是不能忽略的，可以执行对于该信号的默认动作。每种信号都定义了默认的动作，例如硬件故障，默认终止；也可以提供信号处理函数，可以通过sigaction系统调用，注册一个信号处理函数。 





#### （5）进程间通信

 进程间通信方式，消息队列和共享内存 





#### （6）网络通信

 不同机器的通过网络相互通信，要遵循相同的网络协议，也即 TCP/IP 网络协议栈。Linux 内核里有对于网络协议栈的实现。 

 网络服务是通过套接字 Socket 来提供服务的。  在通信之前，双方都要建立一个 Socket 

 以通过 Socket 系统调用建立一个 Socket。Socket 也是一个文件，也有一个文件描述符，也可以通过读写函数进行通信。 





#### （7）Glibc

 Glibc 是 Linux 下使用的开源的标准 C 库，它是 GNU 发布的 libc 库。Glibc 为程序员提供丰富的 API，除了例如字符串处理、数学运算等用户态服务之外，最重要的是封装了操作系统提供的系统服务，即系统调用的封装。 

 每个特定的系统调用对应了至少一个 Glibc 封装的库函数，比如说，系统提供的打开文件系统调用 sys_open 对应的是 Glibc 中的 open 函数。

有时候，Glibc 一个单独的 API 可能调用多个系统调用，比如说，Glibc 提供的 printf 函数就会调用如 sys_open、sys_mmap、sys_write、sys_close 等等系统调用。

也有时候，多个 API 也可能只对应同一个系统调用，如 Glibc 下实现的 malloc、calloc、free 等函数用来分配和释放内存，都利用了内核的 sys_brk 的系统调用。 





 ![img](typora-user-images/ffb6847b94cb0fd086095ac263ac4ff0.jpg) 























































