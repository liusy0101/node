[toc]



# 现代操作系统



## 一、综述

### 1、什么是操作系统

操作系统是一种运行在内核态的软件。

由于硬件的接口极为复杂，所以操作系统的一个主要任务是隐藏硬件，呈现给程序一个良好、清晰、一致的抽象。

现代计算机包含处理器、存储器、时钟、磁盘、网络接口等许多设备，操作系统需要在互相竞争的程序之间有序地控制堆处理器、存储器以及其它IO接口设备的分配。

在多进程和多用户的环境中，操作系统需要记录哪些程序在使用什么资源，对资源请求进行分配，评估使用代价，并为不同的程序和用户之间调解相互冲突的资源请求。

资源管理用两种不同方式实现**多路复用（共享）**资源：在时间上复用和在空间上复用。

- **时间上复用：** 不同程序或用户轮流使用，时间片分割
- **空间上复用：** 都获取一部分资源，取代排队。





### 2、计算机硬件

![image-20210718160025872](typora-user-images/image-20210718160025872.png)

CPU、内存以及IO设备都由一条系统总线连接起来并通过总线与其它设备通信。



#### （1）处理器

CPU从内存中取出指令并执行。

**CPU指令周期：**

- 从内存中取出指令
- 解码，确定类型和操作数
- 执行
- 将结果暂存寄存器



每个CPU都有一套专门指令集，所以，x86处理器不能执行ARM程序，ARM处理器也不能执行x86程序。



**寄存器：**

用来访问内存以得到指令或数据的时间要比执行指令花费的时间长的多，所以，CPU内部会有用来保存关键变量和临时数据的寄存器。

通常在指令集中提供了一些指令，用来将数据从内存读入寄存器，从寄存器读入内存，其它指令可以把来自寄存器、内存的操作数进行计算，将产生的结果存在寄存器或内存中。



**程序计数器：**

也是寄存器，保存了将要取出的下一条指令的内存地址。在指令取出之后，程序计数器就被更新以便指向后继的指令。



**堆栈指针：**

也是寄存器，指向内存中当前栈的顶端。该栈包含了每个执行过程的栈帧。一个过程的栈帧中保存了有关的输入参数、局部变量以及哪些没有保存在寄存器这种的临时变量。



**程序状态字（Program Status Word，PSW）：**

这个寄存器包含了条件码位、CPU优先级、模式（用户态或内核态），以及各种其它控制位。用户程序通常读入整个PSW，但是，只对其中的少量字段写入。在系统调用和IO中，PSW的作用很重要。



操作系统必须知晓所有寄存器，在时间多路复用CPU中，操作系统经常会终止某个进程并启动另一个进程，此时操作系统需要保存所有的寄存器值，以便在后面再次运行该进程时，重新装入这些寄存器，恢复之前状态。



现代CPU具有同时取出多条指令的机制。例如一个CPU可以有单独的取指单元、解码单元和执行单元，当执行指令n时，可解码n+1指令，读取n+2指令，这种成为**流水线**

![image-20210718162243960](typora-user-images/image-20210718162243960.png)



超标量CPU中有多个执行单元，例如一个CPU用于整数计算、一个CPU用于浮点计算、一个CPU用于布尔运算，两个或更多的指令被同时取出、解码并装入暂存缓冲区中，直至它们执行完成。只要有一个执行单元空间，就检查保持缓冲区中是否还有可处理的指令，有则把指令冲缓冲区中移出并执行。



CPU会有两种模式：**内核态**和**用户态**

在PSW中有一个二进制位控制这两种模式，当在内核态运行时，CPU可执行指令集中的每一条指令，并使用硬件的每种功能。操作系统就运行在内核态中

用户程序在用户态下运行，仅允许执行整个指令集的一个子集或访问所有功能的一个子集。

如果用户程序想要从操作系统中获取服务，用户程序必须使用**系统调用**以陷入内核并调用操作系统。

**TRAP**指令把用户态切换成内核态，并启用操作系统，完成后，在系统调用后面的指令把控制权返回给用户程序。



**多线程和多核芯片：**

多线程允许CPU保持两个不同的线程状态，然后在纳秒级的时间尺度内来回切换。

如果某个进程需要从内存中读出一个字（需要花费多个时钟周期），多线程CPU则可切换至另一个线程。多线程不提供真正的并行处理。在某个时刻只有一个进程在运行，单=但线程的切换时间则减少到纳秒数量级。

多核CPU

![image-20210718163820587](typora-user-images/image-20210718163820587.png)

**GPU：** 由成千上万个微核组成的处理器，擅长处理大量并行的简单运算。





#### （2）存储器

存储器系统采用分层次的结构。

![image-20210718164303870](typora-user-images/image-20210718164303870.png)

**寄存器：**

用于CPU相同材料制成，跟CPU一样快。存储容量在32位CPU中是32*32位，在64位CPU中是64\*64位。



**高速缓存行：**

多数由硬件控制，主存被分割成高速缓存行，典型大小为64字节，地址0~63对应高速缓存行0，64~127对应高速缓存行1 。

最常用的高速缓存行放置在CPU内部或非常接近CPU的高速缓存中。

当程序需要读一个存储字时，高速缓存组件检查是否在高速缓存中，如果是，则称为高速缓存命中。缓存满足了请求，就不需要将访问请求送往贮存。

高速缓存命中一般需要两个时钟周期，未命中就必须访问内存，需要大量时间。



现代CPU中设计了两个缓存。

**L1缓存：**

在CPU中，通常用来将已解码的指令调入CPU的执行引擎



**L2缓存：**

存放频繁使用的数据字。



L1、L2缓存之间的差别在于时序，对L1缓存的访问，不存在延时，对L2缓存的访问，则会延时1或2个时钟周期。



**主存：**

存储器系统主力，称为随机访问存储器。





#### （3）磁盘

磁盘随机访问数据时间比内存大约慢了三个数量级。也就是慢了1000倍左右。



**虚拟内存机制：**

使期望运行大于物理内存的程序成为可能，其方法是将程序放在磁盘上，将主存作为一种缓存，用来保存最频繁使用的部分程序。

需要快速地映射内存地址，以便将程序生成的地址转换为有关字节在RAM中的物理地址。

这种映射由CPU中的**存储器管理单元**（Memory Management Unit，MMU）来完成。





#### （4）I/O设备

I/O设备一般包括两个部分：设备控制器核设备本身。

控制器是插在电路板上的一块芯片或一组芯片，这块电路板物理地控制设备，从操作系统接受命令。

实现输入、输出的方式由三种：

**1、忙等待**

用户程序发出一个系统调用，内核将其解析成一个对应设备驱动程序的过程调用，然后设备驱动程序启动IO并在一个连续不断的循环中检查该设备，看是否完成了，当IO结束后，设备驱动程序把数据送到指定的地方并返回。然后操作系统将控制权返回给调用者。



**2、中断**

设备驱动程序启动设备并让该设备在操作完成时发出一个中断。设备驱动程序在这个时刻返回，操作系统在需要时阻塞调用者并安排其它工作进行。当设备驱动程序检测到该设备的操作完毕后，发出一个中断通知操作完成。





![image-20210718171351381](typora-user-images/image-20210718171351381.png)

在操作系统中，中断是非常重要的。

一旦CPU决定取中断，通常程序计数器和PSW就被压入当前堆栈，并切换回用户态。设备编号可成为部分内存的一个引用，用于寻找该设备中断处理程序的地址，这部分内存称为**中断向量**



**3、DMA**

直接存储器访问。

在进行IO设备和内存的数据传输的时候，数据搬运的工作全部交给DMA控制，而CPU不在参与任何与数据搬运相关的事情，此时就能释放CPU资源去处理其他事务。





#### （5）总线

CPU和内存以及其它设备之间，也需要通信，因此用这种特殊的设备进行控制，就是总线。

总线分成3种：

- 地址总线，专门用来指定CPU将要操作的内存地址
- 数据总线，用来读写内存中的数据
- 控制总线，用来发送和接受关键信号，比如中断信号、设备复位等信号，都是通过控制总线传输，同样，CPU需要堆这些信号进行响应，也需要控制总线。

当CPU需要读写内存的时候，先要通过地址总线来指定内存地址，再通过数据总线来传输数据。





#### （6）启动计算机

计算机中有一块双亲板，双亲版上有一个称为**基本输入输出系统（Basic Input Output System，BIOS）**的程序

BIOS内有底层IO软件，包括读键盘、写屏幕、进行磁盘IO以及其它过程。

计算机启动时，BIOS开始运行，首先检查所安装的RAM数量，键盘和其它基本设备是否已安装并正常响应。然后，开始扫描PCIe和PCI总线并找出连在上面的所有设备，即插即用设备也被记录下来。如果现有的设备和系统上一次启动时的设备不同，则新的设备将被配置。

然后，BIOS尝试存储在CMOS存储器中的设备清单决定启动设备，用户可进行BIOS进行启动设备的设置。

然后，操作系统询问BIOS，获取配置信息。





### 3、操作系统概念

#### （1）进程

进程本质上是正在执行的一个程序，相当于程序在内存中的一个副本。

与每个进程相关的是**地址空间**，这是从某个最小值的存储位置到某个最大值的存储位置的列表。

在这个地址空间中，进程可以进行读写。该地址空间还存放有可执行程序、程序的数据以及程序的堆栈。与每个进程相关的还有资源集，通常包括寄存器（含有程序计数器和堆栈指针），打开文件的清单、突出的报警、有关进程清单，以及运行该程序所需要的所有其他信息。

进程基本上是容纳运行一个程序所需要的所有信息的容器。

在操作系统中，存在有一张表，称为**进程表**，进程表是数组或链路的结果，当前存在的每个进程都有记录在进程表中。

当一个进程挂起后，相应的地址空间和进程表项都会保存下来，为后续恢复进程的状态。





#### （2）文件

Linux一切皆文件。

读写文件之前，首先要打开文件，检查其访问权限，若权限许可，系统将返回一个整数，称为**文件描述符（fd）**，若禁止访问，系统返回一个错误码。



**管道：**

管道是一种虚文件，可连接两个进程。

![1626663120942](typora-user-images/1626663120942.png)





#### （3）输入输出



#### （4）保护

用户权限管理，包括用户、用户组

rwx：分别是读、写、执行的权限



比如：

rwxr-x--x：表示所有者可以读写执行，用户组只能读执行，没有写，其他用户可执行。







### 4、系统调用

如果一个进程正在用户态运行一个用户程序，并且需要一个系统服务，比如从一个文件读数据，那么它就必须执行一个陷阱或系统调用指令，将控制转移到操作系统，操作系统通过参数查找所需要的的调用进程，然后执行系统调用，并把控制返回给在系统个调用后面跟随着的指令。

进行系统调用就像进行一个特殊的过程调用，只有系统调用可以进入内核，过程调用不能。



比如`read`系统调用，有三个参数，分别是文件描述符、缓冲区指针、读取字节数。

count = read(fd,buffer,nbytes)

系统调用在count中返回实际读出的字节数。此值通常和nbytes相同，但也可能更小。

如果系统调用不能执行，count会被置为-1，然后在全局变量errno中放入错误号。





![1626664645442](typora-user-images/1626664645442.png)



- 步骤1~步骤3：调用程序首先把参数压进堆栈。
- 步骤4：对库过程的实际调用
- 步骤5：把系统调用的编号放到操作系统期望的地方，比如寄存器
- 步骤6：执行TRAP指令，将用户态切换到内核态，并在内核中的一个固定地址开始执行。
- 步骤7：跟随在TRAP指令后的内核代码开始检查系统调用编号，然后分派到正确的系统调用处理器，这通常是铜鼓哦一张由系统调用编号所引起的、指向系统调用处理器的指针表来完成。
- 步骤8：系统调用处理器运行
- 步骤9：系统调用处理器完成后，控制可能会跟随TRAP指令后面的指令中返回给用户空间库过程。
- 步骤10：以通常的过程调用返回的方式，返回到用户程序。
- 步骤11：增加堆栈指针，继续往下执行。



![1626673205172](typora-user-images/1626673205172.png)

![1626673215847](typora-user-images/1626673215847.png)



#### （1）用于进程管理的系统调用

**fork：**

fork创建一个原有进程的精确副本，包括所有的文件描述符、寄存器等内容。

fork之后，父子进程就分开了，此时所有变量具有一样的值，但其中一个进程的变量的变化不会影响到另一个。

fork调用返回一个值，在子进程中该值为0，并在父进程中等于子进程的**进程标识符（PID）**，根据返回的PID，可确定是父进程还是子进程。



**waitpid：**

waitpid可等待一个特定的子进程，或通过将第一个参数设为 -1 的方式，等待任何一个老的子进程。

waitpid完成后，将把第二个参数statloc所指向的地址设置为子进程的退出状态。





![1626673889499](typora-user-images/1626673889499.png)



**execve：**

三个参数，分别是：将要执行的文件名、指向变量数组的指针、指向环境数组的指针。





进程将其存储空间划分为三段：

- 正文段：如程序代码
- 数据段： 如变量
- 堆栈段

![1626674149351](typora-user-images/1626674149351.png)





#### 2、用于文件管理的系统调用

**open：**

打开文件，通过绝对路径名或指向工作目录的相对路径名指定要打开文件的名称。

代码`O_RDONLY`，`O_WRONLY`，`O_RDWR` 的含义分别是只读、只写、读写。

创新一个新文件，使用`O_CREAT`参数。然后可使用返回的文件描述符进行读写操作。

可用 close 关闭文件，这个调用使得该文件描述符在后续的open中被再次使用。



**write：**

跟read具有相同的参数。



**lseek：**

可改变指针的值，read和write可使用它进行随意位置读写

参数：文件描述符、文件位置、该文件位置是相对于文件起始位置，当前位置还是文件结尾。



**stat:**

查看文件类型、大小、最后修改时间以及其他信息。



#### 3、用于目录管理的系统调用

**link：**

允许同一个文件以两个或多个名称出现，多数情形下是在不同的目录中有相同的文件。

```
link("/usr/a/a.txt","/usr/b/b.txt")
```



每个文件都有唯一的编号，即 i-编号，用以标识文件。

该 i-编号 是对 i-节点表格 的一个引用，一一对应，说明改文件的拥有者、磁盘块的位置等。





**mount：**

将两个文件系统合并成为一个。挂载目录。

比如将 根目录 挂载在磁盘 /dev/sata2 上。













## 二、进程与线程

### 1、进程

在单CPU多道程序设计系统中，CPU由一个进程快速切换至另一个进程，使每个进程各运行几十或几百毫秒，这就是伪并行。



#### （1）进程模型

一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值。

![image-20210720151603175](typora-user-images/image-20210720151603175.png)

只有一个物理程序计数器，每个程序运行时，逻辑程序计数器被装入实际的程序计数器中，当某个程序执行暂停时，物理程序计数器被保存在内存中该进程的逻辑程序计数器中。



#### （2）进程的创建

4种主要事件会创建进程：

- 系统初始化
- 正在运行的程序执行了创建进程的系统调用
- 用户请求创建一个新进程
- 一个批处理作业的初始化



在UNIX系统中，只有一个系统调用可用来创建新进程：`fork`

`fork`会创建一个与调用进程相同的副本，两个进程拥有相同的内存映射、同样的环境等。

通常，子进程接着执行`execve`或一个类似的系统调用，用来修改其内存映像并运行一个新的程序。

进程创建后，父子进程拥有不同的地址空间，其中一个修改了内容不会对另一个造成影响。



#### （3）进程终止

4种情况会终止进程：

- 正常退出
- 出错退出
- 严重错误
- 被其它进程杀死，比如执行系统调用`kill`



执行系统调用`exit`可退出进程





#### （4）进程的层次结构

![image-20210720153350540](typora-user-images/image-20210720153350540.png)

系统中1号进程是系统进程（init 初始化进程），2号是内核进程

其它进程都是由1号或2号进行衍生。

进程和它所有子进程会组成一个进程组，当用户从键盘发出一个信号时，该信号被送给当前与键盘相关的进程组中的所有成员，每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被该信号杀掉。





#### （5）进程的状态

1. 运行态（该时刻进程实际占用CPU）
2. 就绪态（可运行，但因为其它进程正在运行而暂停）
3. 阻塞态（例如等待用户输入等）

![image-20210720153930391](typora-user-images/image-20210720153930391.png)

三种状态有四种的转换关系

转换1：操作系统发现进程不能继续运行下去，比如执行系统调用`pause` 或者 等待用户输入

转换2：系统认为一个运行进程占用CPU时间过长，决定让其它进程使用CPU

转换3：系统已经让所有其它进程享有了它们该有的公平待遇而重新轮到第一个进程再次占用CPU

转换2、3是由进程调度程序引起的，调度程序的主要工作就是决定应当运行哪个进程、何时运行及应该运行多长时间。

转换4：进程等待的外部事件发生时。如果此时没有其它进程在运行，则立即触发转换3，该进程开始运行。否则该进程将处于就绪态，等待CPU空闲并且轮到它运行。



当发生一个磁盘中断时，系统会停止运行当前进程，转而运行磁盘进程，该进程在此之前因等待中断而处于阻塞态。



#### （6）进程实现

操作系统维护了一张表格，即**进程表**

每个进程占用一个进程表项，包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其它在进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后再次启动后能恢复到之前的状态。

![image-20210720155202663](typora-user-images/image-20210720155202663.png)



与每一I/O类关联的是一个叫做**中断向量**的位置。包含了中断服务程序的入口地址，假设当一个磁盘中断发生时，用户进程3正在运行，则中断硬件将程序计数器、程序状态字、一个或多个寄存器压入堆栈，计算机随机跳转到中断向量所指示的地址。

