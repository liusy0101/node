[toc]

# 面试记录
## 前海汇流
### 一面
#### 1.浏览器输入网址后，会发生什么
1. URL解析（是否合法、解析协议、域名等）
2. DNS解析（本地dns缓存、根域名服务器、顶级域名服务器、权威域名服务器）
3. TCP连接（三次握手，为什么不能两次握手）
4. HTTP请求（http和https的区别）
5. 响应请求
6. 解析渲染数据

#### 2.写sql
广告表
表名：ad
字段：id, title, create_time

订单表
表名：order
字段：id, ad_id, cost, create_time

请写一条 SQL，查询订单数量前十的广告，并返回以下信息：广告ID、广告名称、订单数量总和、订单费用总和。

```sql
select b.ad_id,c.title,b.ad_num,b.cost_num from (
select ad_id,ad_num,cost_num from (
select ad_id,count(*) ad_num, sum(cost) cost_num from order group by ad_id order by ad_num limit 10
) b left join ad c on c.id = ad_id
```


#### 3.补充代码
函数 reverse (char *s, int len) 的功能是用递归的方式逆置长度为len的字符串s。例如：若s的内容为“abcd”，则逆置后其内容变为“dcba”，请补充完整下面的代码。

```c++
void reverse (char *s, int len)
{
    char ch;
    if (____1____)
    {
        ch = *s;
        *s = * (s + len - 1);
        * (s + len - 1) = ch;
        reverse (____2____, ____3____);
    }
}
```


## 富途
### 一面
#### 1、梯度计费
1. if、else 暴力解法
2. 使用数组存储数据，然后遍历数组求解
3. 二分法
#### 2、问项目
简历都问一遍，有什么亮点，遇到啥难点咋解决的
#### 3、浏览器输入网址（https）后，会发生什么
#### 4、GMP模型
p没有协程后会干什么
#### 5、逻辑题
一个四分钟的沙漏，一个七分钟的沙漏，如何用这两个沙漏测试出九分钟的时间?
#### 6、Mysql
1. 隔离级别
2. 每种隔离级别都解决啥问题
3. MVCC
4. 回滚机制是咋样的
5. B树和B+树的区别
6. 同一份数据存储在B和B+树上，查找效率有什么不同
#### 7、缓存跟数据库 数据一致性问题

### 二面
#### 介绍项目
让你最深刻的项目是什么、具体是怎么样的，你负责什么东西、架构是如何设计的（包括具体技术层面）
#### 表结构设计
分库分表设计需要考虑什么东西、优缺点这些，实施的时候会遇到什么问题、进行数据库运维的时候遇到什么问题
#### 设计一个对外接口需要考虑什么东西
#### 算法题
给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。
例如，
输入s1=abc,s2=abcd, 输出True;
输入s1=abc,s2=acbd, 输出True;
输入s1=abc,s2=ambnc, 输出False;




## 腾讯文档
### 一面
#### 1、问项目
消息顺序如何保证、长链接流程是咋样的、高并发突增大流量怎么应对
#### 2、Redis主从日志同步
如果有网络波动的情况下该如何处理
#### 3、MySQL主从日志同步是怎么样的
#### 4、实现快排
#### 5、实现dfs
使用递归和循环遍历这两种方式
```go
package main

import "fmt"

type TreeNode struct {
    Value int
    Left  *TreeNode
    Right *TreeNode
}

// 递归实现DFS
func dfsRecursive(node *TreeNode) {
    if node == nil {
        return
    }

    fmt.Println(node.Value)
    dfsRecursive(node.Left)
    dfsRecursive(node.Right)
}

// 非递归实现DFS
func dfsIterative(root *TreeNode) {
    if root == nil {
        return
    }

    stack := []*TreeNode{root}

    for len(stack) > 0 {
        node := stack[len(stack)-1]
        stack = stack[:len(stack)-1]

        fmt.Println(node.Value)

        if node.Right != nil {
            stack = append(stack, node.Right)
        }
        if node.Left != nil {
            stack = append(stack, node.Left)
        }
    }
}
```


## 小红书
### 一面
#### 1、项目
im流程、架构、如何保证消息不丢失、红点问题
#### 2、kafka高可用
副本选主流程、
#### 3、Redis bigKey和热点key问题
#### 算法题
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
```go
package main

import "fmt"

func generateParenthesis(n int) []string {
	var result []string
	generate("", n, n, &result)
	return result
}

func generate(p string, left int, right int, parens *[]string) {
	if left > 0 {
		generate(p+"(", left-1, right, parens)
	}
	if right > left {
		generate(p+")", left, right-1, parens)
	}
	if right == 0 {
		*parens = append(*parens, p)
	}
}

func main() {
	n := 3
	result := generateParenthesis(n)
	fmt.Println(result)
}
```

我的代码
```go
func gen(n int) []string {
	if n <= 0 {
		return nil
	}
	path := make([]byte, 0)
	res := make([]string, 0)

	var dfs func(leftIndex, rightIndex int)
	dfs = func(leftIndex, rightIndex int) {
		if len(path) == 2*n && valid(path) {
			tmp := make([]byte, 2*n)
			copy(tmp, path)
			res = append(res, string(tmp))
			return
		}

		for i := leftIndex; i < n; i++ {
			path = append(path, '(')
			dfs(i+1, rightIndex)
			path = path[:len(path)-1]
		}

		for j := rightIndex; j < n; j++ {
			path = append(path, ')')
			dfs(leftIndex, j+1)
			path = path[:len(path)-1]
		}
	}

	dfs(0, 0)
	return res
}

func valid(byteArr []byte) bool {
	if len(byteArr)%2 == 1 {
		return false
	}

	stack := make([]byte, 0)
	for i := 0; i < len(byteArr); i++ {
		if byteArr[i] == '(' {
			stack = append(stack, '(')
		} else {
			if len(stack) > 0 {
				stack = stack[:len(stack)-1]
			} else {
				return false
			}
		}
	}

	return len(stack) == 0
}
```


## 金山
### 一面
#### 1、context
- 父类context关闭的时候，怎么保证子context已经关闭
- context的value是并发安全的吗
#### 2、map
- 扩容机制
- 扩容的时候读写会怎么样
- 如何创建并发安全的map
- sync.map是怎样的
#### GMP模型
#### mysql
- buffer pool是怎么管理内存的
- buffer pool里面都有啥
- 什么时候回刷新写磁盘
#### redis
- 缓存与数据一致性问题
- 缓存击穿问题
#### 项目
- 应用架构
- 长链接在中台是如何维护的
- 服务发现是怎么处理的
- 机房之间是否可以直接调用
- 切机房之后旧数据是否可以查看


## 迅雷
### 一面
面试官迟到15分钟，差评
#### 1、CPU暴涨怎么排查
#### 2、如何根据ddd思想进行架构设计拆分
#### 3、问我是哪里人、笑死
#### 吧啦吧啦一堆假设问题

差评


## bybit
### 一面
#### 问项目
#### GMP
调度模型、goroutine阻塞的时候怎么处理，g0、m0在其中发挥了什么作用
![](typora-user-images/2023-11-14-19-36-55.png)
#### mysql
插入一条数据的时候数据结构是怎么变化的
#### redis
持久化，RDB持久化方式会阻塞吗？RDB文件生成过程中会阻塞吗
大key有什么现象，有什么危害，怎么解决
#### kafka高性能和高可用是怎么实现的
#### 算法
- 买卖股票
- 快乐数
  ```go
	package main

	import (
		"fmt"
	)

	func isHappy(n int) bool {
		seen := make(map[int]bool)
		for n != 1 && !seen[n] {
			seen[n] = true
			n = calculateNext(n)
		}
		return n == 1
	}

	func calculateNext(n int) int {
		result := 0
		for n > 0 {
			digit := n % 10
			result += digit * digit
			n /= 10
		}
		return result
	}
  ```

  ```go
	func isHappy(n int) bool {
		seen := make(map[int]bool)
		for n != 1 && !seen[n] {
			seen[n] = true
			n = calculateNext(n)
		}
		return n == 1
	}

	func calculateNext(n int) int {
		result := 0
		for n > 0 {
			digit := n % 10
			result += digit * digit
			n /= 10
		}
		return result
	}
  ```


## 字节剪映
### 一面
#### 问项目
#### go如何判断两个类型是否一致
```go
package main

import (
	"fmt"
	"reflect"
)

func main() {
	var x int
	var y float64

	// 获取变量的类型
	typeOfX := reflect.TypeOf(x)
	typeOfY := reflect.TypeOf(y)

	// 判断两个类型是否相同
	if typeOfX == typeOfY {
		fmt.Println("x和y的类型相同")
	} else {
		fmt.Println("x和y的类型不同")
	}

	// 获取变量的种类（Kind）
	kindOfX := typeOfX.Kind()
	kindOfY := typeOfY.Kind()

	// 判断两个类型的种类是否相同
	if kindOfX == kindOfY {
		fmt.Println("x和y的种类相同")
	} else {
		fmt.Println("x和y的种类不同")
	}
}
```
#### go的interface、map是怎么实现的
#### mysql有哪些索引，联合索引是怎么存储的
参考：https://juejin.cn/post/6844904073955639304
![](typora-user-images/2023-11-15-16-08-55.png)
#### 分布式锁是怎么做的，多机房的分布式锁怎么处理
#### 设计个批处理框架，M个数据，N个并发处理，得到M个结果


## 虾皮
### 一面
#### 问项目
#### kafka消息堆积怎么处理
https://juejin.cn/post/7125390146207219719
#### Redis
有几种集群模式，各个优缺点是咋样的
批量写入，有哪些方案
- pipeline
- lua脚本
codis有没了解过
```
Codis 是一个开源的分布式 Redis 解决方案，旨在提供对 Redis 集群的水平扩展和管理支持。它通过在多个 Redis 实例之上构建代理层来实现水平分片，从而允许数据分布在多个 Redis 节点上。

Codis 的主要特性和组件包括：

Proxy（代理层）： Codis 使用代理层作为客户端与 Redis 服务器之间的中间层。代理负责将客户端的请求路由到正确的 Redis 分片上，实现了对 Redis 集群的透明访问。

Coordinator（协调器）： Codis 使用协调器来管理分片信息、监控 Redis 实例的健康状态、以及执行一些全局操作。协调器负责协调整个 Codis 集群的工作。

Dashboard（仪表板）： Codis 提供了一个 Web 页面的仪表板，用于监控和管理 Codis 集群。通过仪表板，你可以查看集群的状态、进行分片管理、查看节点信息等。

HAProxy： Codis 常常与 HAProxy 搭配使用，以实现负载均衡和高可用性。HAProxy 负责将客户端请求分发到 Codis Proxy，并在必要时进行故障转移。

总体而言，Codis 通过将 Redis 分片和代理层结合在一起，提供了一个水平可扩展的 Redis 解决方案。它可以用于处理大规模的数据集，提高读写性能，并提供一些集群管理的功能。需要注意的是，由于 Codis 的一些设计限制，它可能并不适用于所有场景，具体选择需要根据项目的需求和特点进行评估。
```
#### 实时统计请求的p99
#### 算法题
给你一个数组 arr ，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用 -1 替换。

完成所有替换操作后，请你返回这个数组。

示例 1：

输入：arr = [17,18,5,4,6,1]

输出：[18,6,6,6,1,-1]

解决方案：
- 单调栈方式
- 从右往左遍历，保存最大值的数据
  ```go
  func replaceElements(arr []int) []int {
	n := len(arr)
	if n == 0 {
		return arr
	}

	maxRight := -1 // 初始化最后一个元素的右边最大值为-1

	for i := n - 1; i >= 0; i-- {
		current := arr[i] // 当前元素的值
		arr[i] = maxRight // 将当前元素替换为右边最大值
		if current > maxRight {
			maxRight = current // 更新最大值
		}
	}

	return arr
	}
  ```
