# 数据结构与算法



![img](typora-user-images/913e0ababe43a2d57267df5c5f0832a7.jpg)

 

## 一、复杂度分析



### 1、为什么需要复杂度分析

用运行程序得知复杂度是**事后统计法**，有几种缺陷：

- 测试结果严重依赖测试环境
- 测试结果受数据规模影响大

所以，需要一个不用具体的测试数据就能粗略估计算法执行效率的方法。



### 2、大O复杂度表示法

假如一行代码的执行时间是UNIT_TIME，那么所有代码的执行时间T(n)与每行代码的执行次数成正比。
$$
T(n) = O(f(n))
$$

- T(n)是代码执行时间
- n是数据规模大小
- f(n)是每行代码执行的次数总和
- O表示T(n)与f(n)表达式成正比

例如：时间复杂度为 
$$
T(n) = O(2n^2 + 2n)
$$

```java
for(i = 1;i<n;i++) {
    i++;
	for (j = 1;j<n;j++) {
        i+j;
    }
}
```



大O时间复杂度表示法并不代表代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，也叫**渐进时间复杂度**

而公式中的低阶、常量、系数三部分并不影响增长趋势，所以都可以忽略，只需记录一个最大量级，如果用大O表示法表示上述例子的时间复杂度，可以记为：
$$
T(n) = O(n^2)
$$


### 3、时间复杂度分析

（1）只关注循环执行次数最多的一段代码

（2）加法法则：总复杂度等于量级最大的那段代码的复杂度
$$
T1(n)=O(f1(n)),T2(n)=O(f2(n)),
那么T(n)=T1(n)+T2(n)=MAX(O(f1(n)),O(f2(n)))=O(MAX(f1(n),f2(n))
$$
（3）乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
$$
T1(n)=O(f1(n)),T2(n)=O(f2(n)),
那么T(n)=T1(n)*T2(n)=O(f1(n))*O(f2(n))=O(f1(n)*f2(n))
$$
例如：

```java
int a(int[] array) {
    for (int i=0;i<array.length;i++) {
        b(i)
    }
}

int b (int num) {
    for (int i=0;i<num;i++) {
        i++;
    }
}
```



1）单段代码看高频：比如循环。
2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。
3）嵌套代码求乘积：比如递归、多重循环等
4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。 



### 4、常见时间复杂度分析

 ![img](typora-user-images/3723793cc5c810e9d5b06bc95325bf0a.jpg) 

可分为**多项式量级** 和 **非多项式量级** ，后一项只有两个：O(2^n) 和 O(n!)

把时间复杂度为非多项式量级的算法问题叫做NP（ Non-Deterministic Polynomial，非确定多项式） 问题。



**多项式量级复杂度**

#### 1、O(1)

只要算法中不存在循环、递归语句，即使有多行代码，也是O(1)



#### 2、O(logn)、O(nlogn)

例如：下例代码的时间复杂度为O(logn)

```java
 i=1;
 while (i <= n)  {
   i = i * 2;
 }
```

$$
2^x = n , x = logn
$$

即使是
$$
3^x=n, x=log_3n,也是logn,因为log_3n=logn*log_32,系数省略
$$


而O(nlogn)是循环执行O(logn)的代码



#### 3、O(m+n)、O(m*n)

代码复杂度由两个数据的规模决定

无法评估m、n谁的量级大，所以是相加或相乘。



### 5、空间复杂度分析

时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。

空间复杂度是渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系。

就是看分配了多少空间，比如创建了一个容量为n的数组，那么空间复杂度就是O(n)



#### 6、最好、最坏时间复杂度

```java
for (; i < n; ++i) { 
    if (array[i] == x) { 
        pos = i; 
        break; 
    } 
}
```

例如上一段代码，最好情况是O(1)，最坏情况是O(n)

最好时间复杂度就是在最理想的情况下，执行这段代码的时间复杂度。

最坏时间复杂度就是在最糟糕的情况下，执行这段代码的时间复杂度。



### 7、平均时间复杂度

```java
for (; i < n; ++i) { 
    if (array[i] == x) { 
        pos = i; 
        break; 
    } 
}
```

上述代码有n+1种情况，在数组0~n-1位置中和不在数组中，把每种情况需要遍历的次数加起来再平均，就是平均复杂度
$$
\frac{1+2+3+...+n}{n+1} = \frac{n(n+3)}{2(n+1)}
$$
就是O(n)



假设是否在数组中概率都为1/2，查找在数组中概率是1/n，那么就是1/2n，即是
$$
1*\frac{1}{2n}+2*\frac{1}{2n}+...+n*\frac{1}{2n}+n*\frac{1}{2} = \frac{3n+1}{4}
$$
 这个值就是概率论中的加权平均值，也叫作期望值，所以平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。 





### 8、均摊时间复杂度

```java
int[] array = new int[n];
int count = 0; 
void insert(int val) { 
    if (count == array.length) {
        int sum = 0; 
        for (int i = 0; i < array.length; ++i) {
            sum = sum + array[i]; 
        } 
        array[0] = sum; 
        count = 1; 
    } 
    array[count] = val; 
    ++count; 
}
```

例如上述代码，只有数组满了时，才会循环遍历一次，否则都是直接添加

也即是最好是O(1)，最坏是O(n)，

平均为
$$
1*\frac{1}{n+1}+1*\frac{1}{n+1}+...+n*\frac{1}{n+1} = O(1)
$$
 一般都是一个 O(n) 插入之后，紧跟着 n-1 个 O(1) 的插入操作，循环往复。 

**摊还分析法**，通过摊还分析得到的时间复杂度叫均摊时间复杂度。 

大致思路是： 把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1) 



## 二、基础

### 1、数组

数组是一种线性表数据结构，用一组连续的内存空间，存储一组具有相同类型的数据。

**线性表**

数据排成像一条线一样的结构，每个线性表上的数据最多只有前后两个方向。

 ![img](typora-user-images/b6b71ec46935130dff5c4b62cf273477.jpg) 



**非线性表**

数据之间不是简单的前后关系。例如：树、堆、图等。

 ![img](typora-user-images/6ebf42641b5f98f912d36f6bf86f6569.jpg) 



#### （1）数组如何实现随机访问

数组会有一个首地址，也就是下标为0的地址，其他地址按照元素类型进行推算。

 ![img](typora-user-images/98df8e702b14096e7ee4a5141260cdc4.jpg) 

```
a[i]_address = base_address + i * data_type_size
```

- base_address：首地址
- data_type_size：每个元素占多少空间，例如int类型就是4个字节



#### （2）低效的插入和删除

数组由于元素内存是连续的，所以插入和删除都需要移动后面的元素。

最好情况是O(1)，最坏是O(n)。



#### （3）数组下标为何从0开始

数组会有一个首地址，那么下标为0的地址就是首地址，不需要计算，相当于减少了一次CPU计算操作。





#### （4）数组与链表区别

- 数组支持随机访问，根据下标随机访问的时间复杂度是O(1)
- 数组空间是连续的，链表是分散的





### 2、链表

链表存储的元素内存空间不是连续的。

链表有三种常见的结构：单链表、双向链表、循环链表

#### （1）单链表

 ![img](typora-user-images/b93e7ade9bb927baad1348d9a806ddeb.jpg) 

单链表有两个节点比较特殊，头结点和尾节点。

头结点用来记录链表的基地址。

尾节点指针指向一个空地址NULL，表示是链表的最后一个节点。

 数组和链表都支持数据的查找、插入和删除操作！ 

- 数组：
  - 元素无序，查找最好是O(1)，最坏是O(n)
  - 元素有序，查找是O(logn)
  - 插入、删除最好是O(1)，最坏是O(n)
- 链表：
  - 查找都是O(n)
  - 删除和插入的过程是O(1)，但是删除、插入之前查找的过程是O(n)



单链表随机访问需要从头开始遍历，平均时间复杂度是O(n)



#### （2）循环链表

循环链表是在单链表基础上构造的，只不过尾节点的指针指向的是头结点。

 ![img](typora-user-images/86cb7dc331ea958b0a108b911f38d155.jpg) 





#### （3）双向链表

单链表的节点只有指向下一个节点的指针，而双向链表有指向下一个节点和前一个节点的指针。

 ![img](typora-user-images/cbc8ab20276e2f9312030c313a9ef70b.jpg) 

双向链表找到前驱节点的时间复杂度是O(1)，也因为此，使双向链表在某些情况下插入、删除比单链表更简单、高效。

- 删除：
  - 单链表找到对应的节点后，需要遍历找到前驱节点
  - 双向链表有前驱指针

对于有序双向链表查找来说，可以记录上次查找的位置p，然后下一次查找直接从p节点开始。而单链表需要从头遍历。





 对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。 





#### （4）基于链表实现LRU缓存淘汰算法

维护一个单链表，越靠近尾部的节点是越早之前访问的，当新的一个数据被访问时，从链表头开始顺序遍历链表。

1、如果数据已存在链表中，先将其删除，然后插入到链表头部

2、如果数据不存在链表中

- 链表已满：
  - 将尾节点删除，然后新数据插入到链表头部
- 链表未满：
  - 直接将新数据插入到链表头部



优化：引入散列表（hash table）记录每个数据的位置，将缓存访问的时间复杂度降至O(1)



**单链表反转**

```java
/**三个指针**/
public static Node revertList(Node root) {
        if (root == null || root.next == null) {
            return root;
        }
        Node pre = null;
        Node mid = root;
        Node suf = root.next;

        while (1==1) {
            mid.next = pre;

            if (suf == null) {
                break;
            }

            pre = mid;
            mid = suf;
            suf = suf.next;

        }

        root = mid;
        return root;
    }

/**递归解法**/
public static Node revertList2(Node root) {
    if (root == null || root.next == null) {
        return root;
    }
    Node head = revertList2(root.next);

    root.next.next = root;
    root.next = null;
    return head;
}
```



**两个有序链表合成一个**

```java
private static Node merge2List(Node first, Node second) {
        Node head = new Node();
        Node cur = head;

        while (first != null && second != null) {
            if (first.data <= second.data) {
                cur.next = first;
                first = first.next;
            } else {
                cur.next = second;
                second = second.next;
            }
            cur = cur.next;
        }
        if (first != null) {
            cur.next = first;
        }
        if (second != null) {
            cur.next = second;
        }
        return head;

    }

/**递归解法**/
public static Node mergeList_3(Node first, Node second) {
        if (first == null) {
            return second;
        }
        if (second == null) {
            return first;
        }
        if (first.data <= second.data) {
            first.next = mergeList_3(first.next,second);
            return first;
        } else {
            second.next = mergeList_3(first, second.next);
            return second;
        }
    }
```



**链表实现LRU**

```java
public Node findNode(int data) {
        if (isEmpty()) {
            head = new Node(data);
            tail = new Node(data);
        } else {
            Node node = head;
            Node preNode = null;
            while (node != null) {
                if (node.data == data) {
                    //先删除节点
                    preNode.next = node.next;
                    //然后新增节点
                    node.next = head;
                    head = node;
                    return node;
                } else {
                    preNode = node;
                    node = node.next;
                }
            }
            if (isFull()) {
                Node node1 = head;
                Node pre = null;
                while (node1.next != null) {
                    pre = node1;
                    node1 = node1.next;
                }
                pre.next = null;

            }
            Node second = head;
            head = new Node(data);
            head.next = second;
            count++;
        }
        return null;
    }
```



**链表中环监测**

 ![20181013004](typora-user-images/20181013004.png) 

解法1：

快慢指针，

P1是慢指针，一次遍历一个节点。
P2是快指针，一次遍历两个节点。

如果链表中没有环，P2和P1会先后遍历完所有的节点。

如果链表中有环，P2和P1则会先后进入环中，一直循环，并一定会在在某一次遍历中相遇。

因此，只要发现P2和P1相遇了，就可以判定链表中存在环。

```java
/**
     * 判断是否有环 快慢指针法
     * 
     * @param node
     * @return
     */
    public static boolean hasLoopV1(SingleNode headNode) {
        
        if(headNode == null) {
            return false;
        }
        
        SingleNode p = headNode;
        SingleNode q = headNode.next;

        // 快指针未能遍历完所有节点
        while (q != null && q.next != null) {
            p = p.next; // 遍历一个节点
            q = q.next.next; // 遍历两个个节点

            // 已到链表末尾
            if (q == null) {
                return false;
            } else if (p == q) {
                // 快慢指针相遇，存在环
                return true;
            }
        }

        return false;
    }
```



解法二：

足迹检测法， 顺序遍历链表中所有的节点，并将所有遍历过的节点信息保存下来。如果某个节点的信息出现了两次，则存在环。 

```java
// 保存足迹信息
    private static HashMap<SingleNode, Integer> nodeMap = new HashMap<>();

    /**
     * 判断是否有环 足迹法
     * 
     * @param node
     * @return
     */
    public static boolean hasLoopV2(SingleNode node, int index) {
        if (node == null || node.next == null) {
            return false;
        }

        if (nodeMap.containsKey(node)) {
            return true;
        } else {
            nodeMap.put(node, index);
            return hasLoopV2(node.next, ++index);
        }
    }
```



**删除链表倒数第n个节点**

利用快慢指针，快指针先走n个节点，然后慢指针在走，当快指针到尾节点的时候，满指针就到了倒数第n+1个节点。



```java
public static Node deleteLastN(Node root, int n) {
        Node fast = root;
        Node slow = root;
        while (n > 0) {
            fast = fast.next;
            n--;
        }   
        while (fast.next != null) {
            fast = fast.next;
            slow = slow.next;
        }
        slow.next = slow.next.next;
        return root;
    }
```



**查找链表中的中间节点**

```java
public static Node findMidNode(Node root) {
        Node fast = root;
        Node slow = root;

//        while (fast != null) {
//            if (fast.next != null) {
//                fast = fast.next.next;
//            } else {
//              break;
//            }
//            slow = slow.next;
//        }
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;
    }
```



### 3、栈

先进后出，后进先出。

栈可以用数组实现，也可以用链表实现，用数组叫顺序栈，用链表叫链式栈。

入栈出栈时间复杂度都是O(1)

空间复杂度也是O(1)，空间复杂度是除了原本的数据存储空间外，算法运行需要的额外的空间。



**栈在表达式求值中的应用**

通过两个栈来实现，一个是保存操作数，一个是保存运算符的栈，从左到右遍历表达式，遇到数字直接压入数字栈，遇到运算符，先跟运算符栈顶元素比较，如果优先级高于栈顶元素，就压入运算符栈，反之则取出数字栈栈顶两个元素进行运算，将运算结果压入数字栈。

 ![img](typora-user-images/bc77c8d33375750f1700eb7778551600.jpg) 



**栈在括号中的应用**

检查表达式中的括号是否匹配

例如，检测 {[] ()[{}]}或[{()}([])] 是否为合法格式

用一个栈来保存未匹配的左括号，从左到右遍历字符串，当遇到左括号时，压入栈，当遇到右括号时候，从栈顶取出元素，看是否匹配，比如“（”匹配的是“）”，如果不匹配，则不合格，如果遍历完后，栈中没有元素，就说明是合法的。



**如何实现浏览器前进后退**

使用两个栈，x和y，把首次浏览的页面压入x，当点击后退时，从x中弹出，进入y，点击前进时，从y中弹出，进入x。当x没有数据，说明不可后退，当y没有数据，说明不可前进。

比如依次点击a、b、c，此时后退到b，那么b、c就在y栈了，那么在b的时候点击了d页面，c就无法通过前进、后退按钮进行查看了，所以需要清空栈y

 ![img](typora-user-images/a3c926fe3050d9a741f394f20430692e.jpg) 



**为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？**

其实，我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。

从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。 





### 4、队列

先进先出

队列可以用数组和链表实现，用数组叫做顺序队列，用链表叫做链式队列。

对于栈来说，只需要一个栈顶指针

对于队列来说，需要一个指向队列头的指针，一个指向队列尾的指针。

 ![img](typora-user-images/5c0ec42eb797e8a7d48c9dbe89dc93cb.jpg) 



基于数组实现，出队列时候每次head都要往后移，当队列满了之后，无法添加数据，此时需要在入队的时候判断是否已满，如果已满，就进行数据搬迁，此时出队列的时间复杂度就为O(1)。

 ![img](typora-user-images/094ba7722eeec46ead58b40c097353c7.jpg) 



#### （1）循环队列

 ![img](typora-user-images/58ba37bb4102b87d66dffe7148b0f990.jpg) 

添加数据的时候，如果tail指针已经指在队尾，那么会将元素添加至队尾的位置，而tail指针指向0的位置

 ![img](typora-user-images/71a41effb54ccea9dd463bde1b6abe80.jpg) 

tail指针指向的位置是不存放元素的，所以会浪费一个数组的存储空间。

队列空的判断条件：tail == head

队列满的判断条件：（tail+1）% n = head

```java

public class CircularQueue {
  // 数组：items，数组大小：n
  private String[] items;
  private int n = 0;
  // head表示队头下标，tail表示队尾下标
  private int head = 0;
  private int tail = 0;

  // 申请一个大小为capacity的数组
  public CircularQueue(int capacity) {
    items = new String[capacity];
    n = capacity;
  }

  // 入队
  public boolean enqueue(String item) {
    // 队列满了
    if ((tail + 1) % n == head) return false;
    items[tail] = item;
    tail = (tail + 1) % n;
    return true;
  }

  // 出队
  public String dequeue() {
    // 如果head == tail 表示队列为空
    if (head == tail) return null;
    String ret = items[head];
    head = (head + 1) % n;
    return ret;
  }
}
```



#### （2）阻塞队列

队列为空，取数据时阻塞，队列已满，存数据时阻塞。

这就是生产者-消费者模式。

可配置多个消费者，提高并发量处理数据。	

 ![img](typora-user-images/9f539cc0f1edc20e7fa6559193898067.jpg) 



#### （3）并发队列

在出入队列的时候加锁，在锁粒度大的时候并发度会很低。

此时可以使用CAS模式，可实现高效的并发队列。

 CAS实现无锁队列，则在入队前，获取tail位置，入队时比较tail是否发生变化，如果否，则允许入队，反之，本次入队失败。出队则是获取head位置，进行cas。 





### 5、递归

递归需要满足的三个条件：

- 一个问题的解可分解成几个子问题的解
  - 例如 f(n) = f(n-1) +1
- 此问题与分解之后的子问题，除了数据规模不同，求解思路是一样的。
- 存在递归终止条件。



**如何编写递归代码？**

推导递归公式，找到终止条件。



写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。

遇到递归，就把它抽象成一个递推公式，不用考虑一层层的调用关系，不要试图用人脑去分解递归的每个步骤。



**递归代码要警惕堆栈溢出**

可设置递归的最大深度，超过即报错。



**递归代码要警惕重复计算**

可以用散列表保存已求解过的f(k)



### 6、排序

![img](typora-user-images/fb8394a588b12ff6695cfd664afb17cd.jpg)

**如何分析一个排序算法？**

（1）排序算法的执行效率

- 最好情况、最坏情况、平均时间复杂度
- 时间复杂度的系数、常量、低阶
- 比较次数和交换次数

（2）排序算法的内存消耗

原地排序：特指空间复杂度是O(1)的排序算法

（3）排序算法的稳定性

**稳定性：**待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

如果具有稳定性，称为稳定的排序算法，如果前后顺序发生改变，那么对应的排序算法就是不稳定的排序算法。



#### （1）冒泡排序

冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

例如：对一组数据进行排序 4，5，6，3，2，1

![img](typora-user-images/9246f12cca22e5d872cbfce302ef4d09.jpg)

优化：当某次冒泡操作已经没数据交换时，说明已经达到完全有序，就不用继续执行后续的冒泡操作了。

```java

// 冒泡排序，a表示数组，n表示数组大小
public void bubbleSort(int[] a, int n) {
  if (n <= 1) return;
 
 for (int i = 0; i < n; ++i) {
    // 提前退出冒泡循环的标志位
    boolean flag = false;
    for (int j = 0; j < n - i - 1; ++j) {
      if (a[j] > a[j+1]) { // 交换
        int tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp;
        flag = true;  // 表示有数据交换      
      }
    }
    if (!flag) break;  // 没有数据交换，提前退出
  }
}
```

冒泡排序：

- 原地排序
- 稳定

时间复杂度：

最好情况，都是有序的，那么是O（n），最坏情况，逆序排列，那么是O(n^2)

对于平均时间复杂度来说，需通过“有序度”和“逆序度”来进行分析

**有序度**是数组中具有有序关系的元素对的个数

```
有序元素对：a[i] <= a[j], 如果i < j。
```

![img](typora-user-images/a1ef4cc1999d6bd0af08d8417ee55220.jpg)

同理，对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是 n*(n-1)/2，也就是 15。我们把这种完全有序的数组的有序度叫作满有序度。

逆序度 = 满有序度 - 有序度。

排序的过程就是增加有序度，减少逆序度的过程，最后达到满有序度。

冒泡排序包含两个操作原子，比较和交换。每交换一次，有序度就加 1。不管算法怎么改进，交换次数总是确定的，即为逆序度，也就是n*(n-1)/2–初始有序度。此例中就是 15–3=12，要进行 12 次交换操作。

对于包含 n 个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏情况下，初始状态的有序度是 0，所以要进行 n*(n-1)/2 次交换。最好情况下，初始状态的有序度是 n*(n-1)/2，就不需要进行交换。我们可以取个中间值 n*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。

平均情况下，需要 n*(n-1)/4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n2)，所以平均情况下的时间复杂度就是 O(n2)。



#### （2）插入排序

![img](typora-user-images/7b257e179787c633d2bd171a764171a6.jpg)

将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。

![img](typora-user-images/b60f61ec487358ac037bf2b6974d2de1.jpg)



插入排序也包含两种操作，一种是元素的比较，一种是元素的移动。当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。

```java

// 插入排序，a表示数组，n表示数组大小
public void insertionSort(int[] a, int n) {
  if (n <= 1) return;

  for (int i = 1; i < n; ++i) {
    int value = a[i];
    int j = i - 1;
    // 查找插入的位置
    for (; j >= 0; --j) {
      if (a[j] > value) {
        a[j+1] = a[j];  // 数据移动
      } else {
        break;
      }
    }
    a[j+1] = value; // 插入数据
  }
}
```

插入排序也是原地排序、稳定的排序算法。

时间复杂度：

最好情况是都有序，那么是O(n)，如果都是逆序的情况下，那么是O(n^2)

平均也是O(n^2)



#### （3）选择排序

选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

![img](typora-user-images/32371475a0b08f0db9861d102474181d.jpg)

选择排序是原地、不稳定的排序算法。

**为什么不稳定？**

选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。

比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。正是因此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。



时间复杂度都为O(n^2)







**为什么插入排序要比冒泡排序更受欢迎呢？**

从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。

![img](typora-user-images/348604caaf0a1b1d7fee0512822f0e50.jpg)