[toc]



# JVM

JVM是可运行java代码的假想计算机，包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域。

![image-20210529220541873](typora-user-images/image-20210529220541873.png)

![image-20210529220723242](typora-user-images/image-20210529220723242.png)



## 1、线程

程序执行过程中的一个线程实体。

JVM允许一个应用并发执行多个线程。

Hotspot JVM中的Java线程于原生操作系统线程有直接的映射关系。当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。

Java线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把他们分配到任何可用的CPU上。当原生线程初始化完毕，就会调用Java线程的run方法。当线程结束时，会释放原生线程和Java线程的所有资源。



Hotspot JVM后台运行的系统线程主要有下面几个：

![image-20210529221500491](typora-user-images/image-20210529221500491.png)



## 2、JVM内存区域

![image-20210529221621635](typora-user-images/image-20210529221621635.png)

![image-20210529221722477](typora-user-images/image-20210529221722477.png)

**直接内存：** 不是JVM运行时数据区的一部分，也会被频繁的使用。NIO提供了基于Channel于Buffer的IO方式，可以使用Native函数库直接分配对外内存，然后使用DirectByteBuffer对象作为整个内存的引用进行操作，避免了再Java堆和Native堆中来回复制数据，在某些场景中可以显著提高性能。



### （1）程序计数器：线程私有

当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，为线程私有的内润。

正在执行java方法的话，计数器记录的是虚拟机字节码指令的地址。如果是Native方法，则为空。

此内存区域是唯一一个在虚拟机中没有规定任何OutOfMemoryError情况的区域。



### （2）虚拟机栈：线程私有

描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。

每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程 。

栈帧是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接、方法返回值和异常分派。栈帧随着方法调用而创建，随着方法结束而销毁。

![image-20210529222504566](typora-user-images/image-20210529222504566.png)



### （3）本地方法栈：线程私有

与虚拟机栈作用类似，区别是虚拟机栈为执行Java方法服务，本地方法栈为执行Native方法服务。



### （4）堆：线程共享

创建的对象和数组都保存在堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。

分为新生代和老年代，默认比例是1：2

垃圾收集分代回收。



### （5）方法区/永久代：线程共享

用于存储被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 。

Hotspot VM把GC分代收集扩展至方法区，即使用Java堆的永久代来实现方法区，这样HotSpot的垃圾收集器就可以像管理Java堆一样管理这部分内存，而不必为方法区开发专门的内存管理器。永久代的内存回收的主要目标是针对常量池的回收和类型的卸载

**运行时常量池：** 方法区的一部分，class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池。

用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。



## 3、JVM运行时内存

java堆从GC的角度可细分为： 新生代（Eden区、From Survivor区、To Survivor区）和老年代

![image-20210529223557685](typora-user-images/image-20210529223557685.png)



### （1）新生代

用来存放新生的对象，一般占据堆的1/3空间。

由于频繁的创建对象，所以新生代会频繁出发MinorGC进行垃圾回收

新生代又分为Eden、SurvivorForm、SurvivorTo 三个区

#### 1>Eden

Java新对象的出生地，（如果新创建对象占内存很大，则直接分配到老年区）

当Eden区内存不够的时候就会出发MinorGC，对新生代进行一次垃圾回收

#### 2>SurvivorFrom

上一次GC的幸存者，作为此次GC的被扫描者

#### 3>SurvivorTo

保留了一次MinorGC过程中的幸存者



#### 4>MinorGC的过程（复制-清空-交换）

- eden、servicorFrom 复制到 ServicorTo，年龄+1
  首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域（如果有对象的年
  龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 不
  够位置了就放到老年区）；
- 清空 eden、servicorFrom
  然后，清空 Eden 和 ServicorFrom 中的对象；
- ServicorTo 和 ServicorFrom 互换
  最后，ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom
  区。



### （2）老年代

主要存放应用程序中生命周期长的内存对象

老年代的对象比较稳定，所以MajorGC不会频繁执行。在进行Major GC前一半先进行一次MinorGC，使得新生代的对象晋升老年代，导致空间不够用时才出发。当无法找到足够大的连续空间分配给新创建的大对象时也会出发一次MajorGC进行垃圾回收。



### （3）永久代

内存的永久保存区域，主要存放Class和Meta元数据的信息，Class在被加载的时候被放入永久区域，和存放实例的区域不同，GC不会再主程序运行期对永久区域进行清理，所以会导致永久代的区域会随着加载的Class的增多而内存不足，抛出OOM异常。

**Java8中的元数据**

在Java8中，永久代已经被移除，被一个称为“元数据区（元空间）”的区域取代

元空间与永久代的最大区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，类的元数据放入native memory、字符串池和类的静态变量放入java堆中。这样可以加载多少类的元数据就不再由MaxPermSize 控制, 而由系统的实际可用空间来控制。



## 3、垃圾回收算法

![image-20210529225301824](typora-user-images/image-20210529225301824.png)

### （1）如何确认垃圾

##### 1、引用计数法

对象如果没有任何与之关联的引用，即他们的引用计数都不为 0，则说明对象不太可能再被用到，那么这个对象就是可回收对象

#### 2、可达性分析

为了解决引用计数法的循环引用问题，Java 使用了可达性分析的方法。通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。13/04/2018 要注意的是，不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。



### （2）标记-清除算法（Mark-Sweep）

分为两个阶段，标记、清除

先标记出所有需要回收的对象，然后清除被标记的对象所占用的空间。

![image-20210529225812356](typora-user-images/image-20210529225812356.png)

存在内存碎片



### （3）复制算法（copying）

按内存容量将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存满后将依然存活的对象复制到另一块上，把以使用的内存清理掉。

![image-20210529230016196](typora-user-images/image-20210529230016196.png)

虽然没有了空间碎片，但是内存利用率只有百分之五十，且存活的对象增多的话，Copying算法的效率会大大降低。



### （4）标记整理算法（Mark-Compact）

标记后先将存活对象移向内存的一端，然后清除其它的空间。

![image-20210529230216080](typora-user-images/image-20210529230216080.png)



### （5）分代收集算法

老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。

#### 1、新生代与复制算法

新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照 1：1 来划分新生代。一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。

![image-20210529230414454](typora-user-images/image-20210529230414454.png)

#### 2、老年代与标记复制算法

而老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。



1. JAVA 虚拟机提到过的处于方法区的永生代(Permanet Generation)，它用来存储 class 类，
常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。
2. 对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space(Survivor 目
前存放对象的那一块)，少数情况会直接分配到老生代。
3. 当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC，进行 GC 后，Eden 
Space 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 From 
Space 进行清理。
4. 如果 To Space 无法足够存储某个对象，则将这个对象存储到老生代。
5. 在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。
6. 当对象在 Survivor 区躲过一次 GC 后，其年龄就会+1。默认情况下年龄到达 15 的对象会被
移到老生代中。



### （6）分区收集算法

分区算法则将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收. 这样做的好处是可以控制一次回收多少个小区间 , 根据目标停顿时间, 每次合理地回收若干个小区间(而不是整个堆), 从而减少一次 GC 所产生的停顿。







## 5、四种引用类型

### （1）强引用

把一个对象赋给一个引用变量，这个引用变量就是一个强引用。

当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之一。



### （2）软引用

软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。



### （3）弱引用

弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。



### （4）虚引用

虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态





## 6、GC垃圾收集器

堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记-清除垃圾回收算法；年老代主要使用标记-整理垃圾回收算法，因此 java 虚拟中针对新生代和年老代分别提供了多种不同的垃圾收集器，JDK1.6 中 Sun HotSpot 虚拟机的垃圾收集器如下：

![image-20210529231044960](typora-user-images/image-20210529231044960.png)

### （1） Serial垃圾收集器（单线程、复制算法）

Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。Serial 垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此 Serial垃圾收集器依然是 java 虚拟机运行在 Client 模式下默认的新生代垃圾收集器。



### （2）ParNew垃圾收集器（Serial+多线程）

是 Serial 收集器的多线程版本，也使用复制算法，除了使用多线程进行垃圾收集之外，其余的行为和 Serial 收集器完全一样，ParNew 垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程

ParNew 收集器默认开启和 CPU 数目相同的线程数，可以通过-XX:ParallelGCThreads 参数来限制垃圾收集器的线程数。【Parallel：平行的】ParNew虽然是除了多线程外和Serial 收集器几乎完全一样，但是ParNew垃圾收集器是很多 java虚拟机运行在 Server 模式下新生代的默认垃圾收集器



### （3）Parallel Scavenge收集器（多线程复制算法、高效）

Parallel Scavenge 收集器也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃圾收集器，它重点关注的是程序达到一个可控制的吞吐量（Thoughput，CPU 用于运行用户代码的时间/CPU 总消耗时间，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)），高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。自适应调节策略也是 ParallelScavenge 收集器与 ParNew 收集器的一个重要区别。



### （4）Serial Old收集器（单线程标记整理算法）

Serial Old 是 Serial 垃圾收集器年老代版本，它同样是个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在 Client 默认的 java 虚拟机默认的年老代垃圾收集器。

在 Server 模式下，主要有两个用途：

1. 在 JDK1.5 之前版本中与新生代的 Parallel Scavenge 收集器搭配使用。

2. 作为年老代中使用 CMS 收集器的后备垃圾收集方案。

新生代 Serial 与年老代 Serial Old 搭配垃圾收集过程图

![image-20210529231634143](typora-user-images/image-20210529231634143.png)

新生代 Parallel Scavenge 收集器与 ParNew 收集器工作原理类似，都是多线程的收集器，都使用的是复制算法，在垃圾收集过程中都需要暂停所有的工作线程。

新生代 Parallel Scavenge/ParNew 与年老代 Serial Old 搭配垃圾收集过程图：

![image-20210529231741687](typora-user-images/image-20210529231741687.png)



### （5）Parallel Old收集器（多线程标记整理算法）

Parallel Old 收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法

在 JDK1.6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old 正是为了在年老代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，可以优先考虑新生代 Parallel Scavenge和年老代 Parallel Old 收集器的搭配策略。

新生代 Parallel Scavenge 和年老代 Parallel Old 收集器搭配运行过程图：

![image-20210529231920167](typora-user-images/image-20210529231920167.png)



### （6）CMS收集器（多线程标记清除算法）

Concurrent mark sweep(CMS)收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。

整个过程分为4个阶段：

#### 1、初始标记

只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程

#### 2、并发标记

进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。

#### 3、重新标记

为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。

#### 4、并发清除

清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行

![image-20210529232241602](typora-user-images/image-20210529232241602.png)



### （7）G1收集器

详细参考：https://www.cnblogs.com/aspirant/p/8663872.html

​				  https://tech.meituan.com/2016/09/23/g1.html

相比于CMS收集器来说，G1收集器两个最突出的改进是：

1. 基于标记-整理算法，不产生内存碎片。

2. 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。

G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率

**G1虽然也把内存分成了这三大类，但是在G1里面这三大类不是泾渭分明的三大块内存，G1把内存划分成很多小块, 每个小块会被标记为E/S/O中的一个，可以前面一个是Eden后面一个就变成Survivor了。**

![img](typora-user-images/19049-6326d8cc7bbdbcc3.png)

![image-20210529233157512](typora-user-images/image-20210529233157512.png)



#### （1）Region

传统的GC收集器将连续的内存空间划分为新生代、老年代和永久代（元空间），个贷的存储地址是连续的。

 ![传统GC内存布局](typora-user-images/8a9db36e.png) 

而G1的各代存储地址是不连续的，每一代都是用了n个不连续的大小相同的Region，每个Region占有一块连续的虚拟内存地址。

 ![g1 GC内存布局](typora-user-images/8ca16868.png) 

**H：** 表示这些Region存储的是巨大对象（H-Objs），即是大小大于等于region一半的对象。



 H-obj有如下几个特征：

* H-obj直接分配到了old gen，防止了反复拷贝移动。 
* H-obj在global concurrent marking阶段的cleanup 和 full GC阶段回收。 
* 在分配H-obj之前先检查是否超过 initiating heap occupancy percent和the marking threshold, 如果超过的话，就启动global concurrent marking，为的是提早回收，防止 evacuation failures 和 full GC。 



一个Region的大小可通过参数-XX:G1HeapRegionSize设定，取值范围是 1m~32m，且是2的指数。

默认的Region个数是2048个。



#### （2）RSet

Remembered Set，辅助GC过程的一种结构，典型的空间换时间工具，和Card Table类似。还有一种数据结构也是辅助GC的：Collection Set（CSet），记录了GC要收集的Region集合，集合里的Region可是任意年代的。

在GC时，对于old->young 和old->old的跨代对象引用，只要扫描对应的CSet中的RSet即可。

 逻辑上说每个Region都有一个RSet，RSet记录了其他Region中的对象引用本Region中对象的关系，属于points-into结构（谁引用了我的对象）。而Card Table则是一种points-out（我引用了谁的对象）的结构，每个Card 覆盖一定范围的Heap（一般为512Bytes）。G1的RSet是在Card Table的基础上实现的：每个Region会记录下别的Region有指向自己的指针，并标记这些指针分别在哪些Card的范围内。 这个RSet其实是一个Hash Table，Key是别的Region的起始地址，Value是一个集合，里面的元素是Card Table的Index。 

 ![Remembered Sets](typora-user-images/5aea17be.jpg) 

 上图中有三个Region，每个Region被分成了多个Card，在不同Region中的Card会相互引用，Region1中的Card中的对象引用了Region2中的Card中的对象，蓝色实线表示的就是points-out的关系，而在Region2的RSet中，记录了Region1的Card，即红色虚线表示的关系，这就是points-into。 而维系RSet中的引用关系靠post-write barrier和Concurrent refinement threads来维护 



#### （3）停顿预测模型

 用户可以设定整个GC过程的期望停顿时间，参数-XX:MaxGCPauseMillis指定一个G1收集过程目标停顿时间，默认值200ms，不过它不是硬性条件，只是期望值。

**那么G1怎么满足用户的期望呢？**

就需要这个停顿预测模型了。G1根据这个模型统计计算出来的历史数据来预测本次收集需要选择的Region数量，从而尽量满足用户设定的目标停顿时间。 



#### （4）GC过程

G1提供了两种GC模式：Young GC和Mixed GC。两种都是完全stop the world的。

**Young GC：** 选定所有年轻代里的Region，通过控制年轻代的region个数，即年轻代内存大小，来控制Young GC的时间开销。

**Mixed GC：** 选定所有年轻代的Region，外加根据global concurrent marking统计得出收集收益高的若干老年代region。在用户指定的开销目标范围内尽可能选择收益高的老年代Region。

Mixed GC不是fullGC，只能回收部分老年代的region，如果mixed GC是在无法跟上程序分配内存的速度，导致老年代填满无法继续进行Mixed GC，就会使用Serial Old（full GC）来收集整个gc heap。

 global concurrent marking，它的执行过程类似CMS，但是不同的是，在G1 GC中，它主要是为Mixed GC提供标记服务的，并不是一次GC过程的一个必须环节。

global concurrent marking的执行过程分为四个步骤： 

* 初始标记（initial mark，STW）。它标记了从GC Root开始直接可达的对象。 
* 并发标记（Concurrent Marking）。这个阶段从GC Root开始对heap中的对象标记，标记线程与应用程序线程并行执行，并且收集各个Region的存活对象信息。 
* 最终标记（Remark，STW）。标记那些在并发标记阶段发生变化的对象，将被回收。 
* 清除垃圾（Cleanup）。清除空Region（没有存活对象的），加入到free list。 

 第一阶段initial mark是共用了Young GC的暂停，这是因为他们可以复用root scan操作，所以可以说global concurrent marking是伴随Young GC而发生的。第四阶段Cleanup只是回收了没有存活对象的Region，所以它并不需要STW。 



**什么时候发生Mixed GC呢？**

其实是由一些参数控制着的，另外也控制着哪些老年代Region会被选入CSet。

* G1HeapWastePercent：在global concurrent marking结束之后，我们可以知道old gen regions中有多少空间要被回收，在每次YGC之后和再次发生Mixed GC之前，会检查垃圾占比是否达到此参数，只有达到了，下次才会发生Mixed GC。 
*  G1MixedGCLiveThresholdPercent：old generation region中的存活对象的占比，只有在此参数之下，才会被选入CSet。 
* G1MixedGCCountTarget：一次global concurrent marking之后，最多执行Mixed GC的次数。 
*  G1OldCSetRegionThresholdPercent：一次Mixed GC中能被选入CSet的最多old generation region数量。 

| 参数                               | 含义                                                         |
| :--------------------------------- | :----------------------------------------------------------- |
| -XX:G1HeapRegionSize=n             | 设置Region大小，并非最终值                                   |
| -XX:MaxGCPauseMillis               | 设置G1收集过程目标时间，默认值200ms，不是硬性条件            |
| -XX:G1NewSizePercent               | 新生代最小值，默认值5%                                       |
| -XX:G1MaxNewSizePercent            | 新生代最大值，默认值60%                                      |
| -XX:ParallelGCThreads              | STW期间，并行GC线程数                                        |
| -XX:ConcGCThreads=n                | 并发标记阶段，并行执行的线程数                               |
| -XX:InitiatingHeapOccupancyPercent | 设置触发标记周期的 Java 堆占用率阈值。默认值是45%。这里的java堆占比指的是non_young_capacity_bytes，包括old+humongous |









#### （1）G1的年轻代

堆空间最多被分成2048个区域。最小1M，最大32M，蓝色区域保持年老代对象，绿色区域保持年轻代对象。 

![image-20210529233348119](typora-user-images/image-20210529233348119.png)



#### 关键命令行开关

**-XX:+UseG1GC** - 告诉Java虚拟机使用G1垃圾收集器 
**-XX:MaxGCPauseMillis=200** - 为最大GC暂停时间设置一个指标。这是一个软目标，Java虚拟机将尽最大努力实现它。因此，暂停时间目标有时候可能不会达到。默认值是200毫秒。 
**-XX:InitiatingHeapOccupancyPercent=45** - 触发并发垃圾收集周期的整个堆的百分比时机。

这是一个G1垃圾收集器开关的完整列表，记着去使用上述的最佳实践。

| 选项和默认值                         | 描述                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| -XX:+UseG1GC                         | 使用垃圾优先(G1,Garbage First)收集器                         |
| -XX:MaxGCPauseMillis=n               | 设置垃圾收集暂停时间最大值指标。这是一个软目标，Java虚拟机将尽最大努力实现它 |
| -XX:InitiatingHeapOccupancyPercent=n | 触发并发垃圾收集周期的整个堆空间的占用比例。它被垃圾收集使用，用来触发并发垃圾收集周期，基于整个堆的占用情况，不只是一个代上(比如：G1)。0值 表示’do constant GC cycles’。默认是45 |
| -XX:NewRatio=n                       | 年轻代与年老代的大小比例，默认值是2                          |
| -XX:SurvivorRatio=n                  | eden与survivor空间的大小比例，默认值8                        |
| -XX:MaxTenuringThreshold=n           | 最大晋升阈值，默认值15                                       |
| -XX:ParallerGCThreads=n              | 设置垃圾收集器并行阶段的线程数量。默认值根据Java虚拟机运行的平台有所变化 |
| -XX:ConcGCThreads=n                  | 并发垃圾收集器使用的线程数量，默认值根据Java虚拟机运行的平台有所变化 |
| -XX:G1ReservePercent=n               | 为了降低晋升失败机率设置一个假的堆的储备空间的上限大小，默认值是10 |
| -XX:G1HeapRegionSize=n               | 使用G1收集器，Java堆被细分成一致大小的区域。这设置个体的细分的大小。这个参数的默认值由工学意义上的基于堆的大小决定 |



G1回收的过程：

- 在垃圾回收的最开始有一个短暂的时间段(Inital Mark)会停止应用(stop-the-world)
- 然后应用继续运行，同时G1开始Concurrent Mark
- 再次停止应用，来一个Final Mark (stop-the-world)
- 最后根据Garbage First的原则，选择一些内存块进行回收。(stop-the-world)



G1为什么能设置应用的暂停时间：

**因为其可以选择内存块进行回收，而不是整代内存来回收，这是G1跟其它GC不同的而一点。其它GC每次回收都会回收整个Generation的内存(Eden, Old), 而回收内存所需的时间就取决于内存的大小，以及实际垃圾的多少，所以垃圾回收时间是不可控的；而G1每次并不会回收整代内存，到底回收多少内存就看用户配置的暂停时间，配置的时间短就少回收点，配置的时间长就多回收点，伸缩自如。**



**缺点：**

如果应用的内存非常吃紧，对内存进行部分回收根本不够，始终要进行整个Heap的回收，那么G1要做的工作量就一点也不会比其它垃圾回收器少，而且因为本身算法复杂了一点，可能比其它回收器还要差。因此G1比较适合内存稍大一点的应用(一般来说至少4G以上)，小内存的应用还是用传统的垃圾回收器比如CMS比较合适。



**总结：**

G1通过在垃圾回收领域应用并行化的策略，把几块大内存块的回收问题，变成了几百块小内存的回收问题，使得回收算法可以高度并行化，同时也因为分成很多小块，使得垃圾回收的单位变成了小块内存，而不是整代内存，使得用户可能对回收时间进行配置，垃圾回收变得可以预期了。



## 7、类文件结构

### （1）Class类文件结构

任何一个Class文件都对应着唯一的一个类或接口的定义信息。

Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符，整个Class文件存储的内容几乎全部是程序运行的必要数据。

当遇到需占用8个字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8个字节进行存储。

Class文件采用的是类似C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数、表

- 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。

- 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表，这张表由下图所示的数据项按严格顺序排列构成

![1624346495066](typora-user-images/1624346495066.png)



#### 1、魔数与Class文件的版本

每个Class文件的头4个字节被称为**魔数（Magic Number）**，它的唯一作用是确定这个文件是否为一个能被虚拟机接收的Class文件。

魔数是固定的：0xCAFEBABE

紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是**次版本号（Minor Version）**，第7和第8个字节是**主版本号（Major Version）**

![1624346979399](typora-user-images/1624346979399.png)



#### 2、常量

紧接着版本后的是常量池入口。

常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表**常量池容量计数值（constant_pool_count）**。

 这个容量计数是从1而不是0开始的，如下图所示，常量池容量（偏移地址：0x00000008）为十六进制数0x0016，即十进制的22，这就代表常量池中有21项常量，索引值范围为1～21。在Class文件格式规范制定之时，设计者将第0项常量空出来是有特殊考虑的，这样做的目的在于，如果后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，可以把索引值设置为0来表示。 

![1624347290945](typora-user-images/1624347290945.png)

常量池主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。

字面量比较接近Java层面的常量概念，如文本字符串、被声明为final的常量值等。

符号引用则属于编译原理方面的概念，主要包括下面几类：

-  ·被模块导出或者开放的包（Package）
- ·类和接口的全限定名（FullyQualifiedName）
- ·字段的名称和描述符（Descriptor）
- ·方法的名称和描述符·方法句柄和方法类型（MethodHandle、MethodType、InvokeDynamic）
- ·动态调用点和动态常量（Dynamically-ComputedCallSite、Dynamically-ComputedConstant） 



 常量池中每一项常量都是一个表 

![1624348557503](typora-user-images/1624348557503.png)

![1624348568256](typora-user-images/1624348568256.png)



 常量池的第一项常量，它的标志位（偏移地址：0x0000000A）是0x07，查表6-3的标志列可知这个常量属于CONSTANT_Class_info类型，此类型的常量代表一个类或者接口的符号引用。CONSTANT_Class_info的结构比较简单，如表6-4所示

![1624348615953](typora-user-images/1624348615953.png)

 tag是标志位，它用于区分常量类型；name_index是常量池的索引值，它指向常量池中一个CONSTANT_Utf8_info类型常量，此常量代表了这个类（或者接口）的全限定名，本例中的name_index值（偏移地址：0x0000000B）为0x0002，也就是指向了常量池中的第二项常量。

继续从图6-3中查找第二项常量，它的标志位（地址：0x0000000D）是0x01，查表6-3可知确实是一个CONSTANT_Utf8_info类型的常量。CONSTANT_Utf8_info类型的结构如表6-5所示。 

![1624348749787](typora-user-images/1624348749787.png)



 length值说明了这个UTF-8编码的字符串长度是多少字节，它后面紧跟着的长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串。 

 本例中这个字符串的length值（偏移地址：0x0000000E）为0x001D，也就是长29个字节，往后29个字节正好都在1～127的ASCII码范围以内，内容为“org/fenixsoft/clazz/TestClass”

![1624348825994](typora-user-images/1624348825994.png)



![1624348882839](typora-user-images/1624348882839.png)

![1624348900725](typora-user-images/1624348900725.png)

![1624348924050](typora-user-images/1624348924050.png)

![1624348937338](typora-user-images/1624348937338.png)



#### 3、访问标识

紧接着常量池的2个字节代表**访问标识（access_flag）**，用于识别一些类或者接口层次的访问信息。

包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final

![1624349073218](typora-user-images/1624349073218.png)



#### 4、类索引、父类索引、接口索引集合

 类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定该类型的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。 

 接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements关键字（如果这个Class文件表示的是一个接口，则应当是extends关键字）后的接口顺序从左到右排列在接口索引集合中

 类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。 

![1624349586779](typora-user-images/1624349586779.png)

比如类索引是 0x0001

![1624349612815](typora-user-images/1624349612815.png)

 从偏移地址0x000000F1开始的3个u2类型的值分别为0x0001、0x0003、0x0000，也就是类索引为1，父类索引为3，接口索引集合大小为0



#### 5、字段表集合

字段表（field_info）用于描述接口或者类中声明的变量。Java语言中的“字段”（Field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。 

![1624349863855](typora-user-images/1624349863855.png)

 字段修饰符放在access_flags项目中，它与类中的access_flags项目是非常类似的，都是一个u2的数据类型，其中可以设置的标志位和含义如表6-9所示

![1624349883966](typora-user-images/1624349883966.png)

 跟随access_flags标志的是两项索引值：name_index和descriptor_index。它们都是对常量池项的引用，分别代表着字段的简单名称以及字段和方法的描述符。 

**简单名称：**  指没有类型和参数修饰的方法或者字段名称，这个类中的inc()方法和m字段的简单名称分别就是“inc”和“m”

**描述符：**  用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值

![1624350013298](typora-user-images/1624350013298.png)



 对于数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义为“java.lang.String[][]”类型的二维数组将被记录成“[[Ljava/lang/String；”，一个整型数组“int[]”将被记录成“[I”。

用描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法voidinc()的描述符为“()V”，方法java.lang.StringtoString()的描述符为“()Ljava/lang/String；”，

方法intindexOf(char[]source，intsourceOffset，intsourceCount，char[]target，inttargetOffset，inttargetCount，intfromIndex)的描述符为“([CII[CIII)I”



#### 6、方法表集合

 方法表的结构如同字段表一样，依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项， 

![1624352249055](typora-user-images/1624352249055.png)



![1624352281238](typora-user-images/1624352281238.png)

 方法里的Java代码，经过Javac编译器编译成字节码指令之后，存放在方法属性表集合中一个名为“Code”的属性里面，属性表作为Class文件格式中最具扩展性的一种数据项目

 在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名[2]。特征签名是指一个方法中各个参数在常量池中的字段符号引用的集合，也正是因为返回值不会包含在特征签名之中，所以Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。 



#### 7、属性表集合

Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。

![1624352597571](typora-user-images/1624352597571.png)

![1624352622528](typora-user-images/1624352622528.png)



 对于每一个属性，它的名称都要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可。一个符合规则的属性表应该满足表6-14中所定义的结构。 

![1624352657228](typora-user-images/1624352657228.png)







### （2）字节码指令

Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（操作码）以及跟随其后的零至多个代表此操作所需的参数（操作数）构成。

#### 1、字节码与数据类型

 大多数指令都包含其操作所对应的数据类型信息。

举个例子，iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。 

 对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：

- i代表对int类型的数据操作，
- l代表long，
- s代表short，
- b代表byte，
- c代表char，
- f代表float，
- d代表double，
- a代表reference。 

![1624353508569](typora-user-images/1624353508569.png)

![1624353531976](typora-user-images/1624353531976.png)



#### 2、加载与存储指令

- ·将一个局部变量加载到操作栈：iload、iload_<n>、lload、lload_<n>、fload、fload_<n>、dload、dload_<n>、aload、aload_<n>·_
- _将一个数值从操作数栈存储到局部变量表：istore、istore_<n>、lstore、lstore_<n>、fstore、fstore_<n>、dstore、dstore_<n>、astore、astore_<n>
- ·将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_<i>、lconst_<l>、fconst_<f>、dconst_<d>
- ·扩充局部变量表的访问索引的指令：wide 

![1624353692116](typora-user-images/1624353692116.png)

iload_0的语义与操作数为0时的iload指令语义完全一致



#### 3、运算指令

 算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。 

- ·加法指令：iadd、ladd、fadd、dadd
- ·减法指令：isub、lsub、fsub、dsub
- ·乘法指令：imul、lmul、fmul、dmul
- ·除法指令：idiv、ldiv、fdiv、ddiv
- ·求余指令：irem、lrem、frem、drem
- ·取反指令：ineg、lneg、fneg、dneg
- ·位移指令：ishl、ishr、iushr、lshl、lshr、lushr
- ·按位或指令：ior、lor
- ·按位与指令：iand、land
- ·按位异或指令：ixor、lxor
- ·局部变量自增指令：iinc
- ·比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp 



#### 4、类型转换指令

类型转换指令可以将两种不同的数值类型相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理本节开篇所提到的字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。 

- ·int类型到long、float或者double类型
- ·long类型到float、double类型
- ·float类型到double类型

与之相对的，处理窄化类型转换（NarrowingNumericConversion）时，就必须显式地使用转换指令来完成，这些转换指令包括i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f。



#### 5、对象创建与访问指令

- ·创类例指：e·建组指：earyaearymlinwra
- ·问字（ttc段或称类量和例段非ttc段或称实变）指：efedptil、esai、usai
- ·一数元加到作栈指：aodcla、aodila、aodfla、aodala
- ·一操数的储到组素的令bsoecsoessoeisoefsoedsoeasoe取组度指：ralnt
- ·查实类的令isaco、hccs



####  6、操作数栈管理指令

- ·将作栈栈一或个素栈pppp
- ·制顶个两数并复值双的制重压栈：u、u2dpx、u2x、u_2dp_2
-  将栈最顶端的两个数值互换：swap 



#### 7、控制转移指令

- ·条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne
- ·复合条件分支：tableswitch、lookupswitch
- ·无条件分支：goto、goto_w、jsr、jsr_w、ret 



#### 8、方法调用和返回指令

- ·invokevirtual指令：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式。
- ·invokeinterface指令：用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。
- ·invokespecial指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。
- ·invokestatic指令：用于调用类静态方法（static方法）。
- ·invokedynamic指令：用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法。前面四条调用指令的分派逻辑都固化在Java虚拟机内部，用户无法改变，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。 



 方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的，包括ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn，另外还有一条return指令供声明为void的方法、实例初始化方法、类和接口的类初始化方法使用。 





#### 9、同步指令

 Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor，更常见的是直接将它称为“锁”）来实现的

 方法级的同步是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池中的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否被声明为同步方法。当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放

 **同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义，正确实现synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持**



![1624354344758](typora-user-images/1624354344758.png)



 编译器必须确保无论方法通过何种方式完成，方法中调用过的每条monitorenter指令都必须有其对应的monitorexit指令，而无论这个方法是正常结束还是异常结束 

  **为了保证在方法异常完成时monitorenter和monitorexit指令依然可以正确配对执行，编译器会自动产生一个异常处理程序，这个异常处理程序声明可处理所有的异常，它的目的就是用来执行monitorexit指令**







































## 8、JVM类加载机制

JVM类加载机制分为五个部分：加载、验证、解析、准备、初始化、

![image-20210529233924240](typora-user-images/image-20210529233924240.png)

### （1）加载

Java虚拟机主要完成三件事情：

- 通过类的全限定名来获取定义此类的二进制字节流
- 将这个字节流所代表的静态存储结构转换成方法区的运行时数据结构
- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

获取源头：

- Class文件
- Zip包
- jar包、war包
- 运行时计算生成（动态代理）
- 可由其它文件生成（将JSP文件转换成对应的Class类）



**数组加载过程如下：**

数组类本身不通过类加载器创建，是由Java虚拟机直接在内存中动态构造出来的。但数组的元素还是要考类加载器来完成加载。

- 如果元素是引用类型，那就递归加载此类型，数组将被标识在加载该组件类型的类加载器的类名称空间上。
- 如果元素不是引用类型（例如int[]），虚拟机将会把数组标记为与引导类加载器关联
- 数组的可访问性与它的元素类型的可访问性一致，如果元素类型不是引用类型，它的数组类的可访问性将默认为public。



加载阶段结束后，虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区中了。



### （2）验证

为了确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并不会危害虚拟机自身的安全

验证阶段包括4个阶段：

1. 文件格式验证： 验证字节流是否符合Class文件格式的规范，比如是否以0xCAFEBABE开头、主次版本好是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型
2. 元数据验证： 对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求，比如这个类是否有父类，除了Object类之外
3. 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的
4. 符号引用验证： 确保解析动作能正确执行





### （3）准备

为类的**静态变量**分配内存，并将其初始化为默认值

为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些便来给你所使用的内存空间

​	1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。

​    2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。

注意这里所说的处置使概念，例如一个类变量定义为：

```java
public static int v = 8080;
```

实际上便来给你v在准备阶段过后的初始值为0而不是8080，将v赋值为8080的put static指令是在程序被编译后，存放于类构造器<clinit>方法中

但是注意如果声明为：

```java
public static final int v = 8080;
```

在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v赋值为 8080



**注意：**

```
· 对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。
· 对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。
· 对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。
· 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。
```

 3、如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。

### （4）解析

虚拟机将常量池中的符号引用替换为直接引用的过程。

解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。**符号引用**就是一组符号来描述目标，可以是任何字面量。

符号引用就是class文件中的：

1. CONSTANT_Class_info

2. CONSTANT_Field_info

3. CONSTANT_Method_info

等类型的常量。

#### 1、符号引用

用一组符号来表述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。

符号引用与虚拟机实现的布局无关，引用过的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是他们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。

#### 2、直接引用

直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。



### （5）初始化

初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：

 ①声明类变量是指定初始值

 ②使用静态代码块为类变量指定初始值

JVM初始化步骤

 1、假如这个类还没有被加载和连接，则程序先加载并连接该类

 2、假如该类的直接父类还没有被初始化，则先初始化其直接父类

 3、假如类中有初始化语句，则系统依次执行这些初始化语句



类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：

- 创建类的实例，也就是new的方式
- 访问某个类或接口的静态变量，或者对该静态变量赋值
- 调用类的静态方法
- 反射（如Class.forName(“com.shengsiyuan.Test”)）
- 初始化某个类的子类，则其父类也会被初始化
- Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类



### （6）类构造器<clinit>

初始化阶段是执行类构造器<clinit>方法的过程。<clinit>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。

虚拟机会保证子<clinit>方法执行之前，父类的<clinit>方法已经执行完毕

如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<client>方法。



注意以下集中情况不会执行类初始化：

1. 通过子类引用父类的静态字段，只会触发父类的初始化，不会触发子类的初始化
2. 定义对象数组，不会触发该类的初始化
3. 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类
4. 通过类名获取Class对象，不会触发类的初始化
5. 通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化
6. 通过ClassLoader默认的loadClass方法，也不会触发初始化动作。





### 7、类加载器

#### （1）启动类加载器(Bootstrap ClassLoader)

负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath 参数指定路径中的，且被虚拟机认可（按文件名识别，如 rt.jar）的类。

#### （2） 扩展类加载器(Extension ClassLoader)

负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类库。

#### （3）应用程序类加载器(Application ClassLoader)：

负责加载用户路径（classpath）上的类库。JVM 通过双亲委派模型进行类的加载，当然我们也可以通过继承 java.lang.ClassLoader实现自定义的类加载器。

![image-20210530000116117](typora-user-images/image-20210530000116117.png)





### 8、双亲委派

当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。

采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。

<img src="typora-user-images/image-20210530000226183.png" alt="image-20210530000226183" style="zoom:200%;" />





### 8、OSGI（动态模型系统）

OSGi(Open Service Gateway Initiative)，是面向 Java 的动态模型系统，是 Java 动态化模块化系统的一系列规范。

### （1）动态改变构造

OSGi 服务平台提供在多种网络设备上无需重启的动态改变构造的功能。为了最小化耦合度和促使这些耦合度可管理，OSGi 技术提供一种面向服务的架构，它能使这些组件动态地发现对方。

#### （2）模块化编程与热插拔

OSGi 旨在为实现 Java 程序的模块化编程提供基础条件，基于 OSGi 的程序很可能可以实现模块级的热插拔功能，当程序升级更新时，可以只停用、重新安装然后启动程序的其中一部分，这对企业级程序开发来说是非常具有诱惑力的特性。

OSGi 描绘了一个很美好的模块化开发目标，而且定义了实现这个目标的所需要服务与架构，同时也有成熟的框架进行实现支持。但并非所有的应用都适合采用 OSGi 作为基础架构，它在提供强大功能同时，也引入了额外的复杂度，因为它不遵守了类加载的双亲委托模型。





## 9、JVM调优

 **活跃数据的大小**是指，应用程序稳定运行时长期存活对象在堆中占用的空间大小，也就是Full GC后堆中老年代占用空间的大小。 

| 空间   | 倍数                                    |
| :----- | :-------------------------------------- |
| 总大小 | **3-4** 倍活跃数据的大小                |
| 新生代 | **1-1.5** 活跃数据的大小                |
| 老年代 | **2-3** 倍活跃数据的大小                |
| 永久代 | **1.2-1.5** 倍Full GC后的永久代空间占用 |





### （1）何时进行JVM调优

- Heap内存（老年代）持续上涨达到设置的最大内存值
- Full GC次数频繁
- GC停顿时间过长（超过1秒）
- 应用出现OutOfMemory等内存异常
- 应用中有使用本地缓存且占用大量内存空间
- 系统吞吐量与响应性能不高或下降。



### （2）调优目标

- 延迟：GC低停顿和GC低频率
- 低内存占用
- 高吞吐量



### （3）调优步骤

1. 分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点
2. 确定JVM调优量化目标



4. 依次调优内存、延迟、吞吐量等指标
5. 对比观察调优前后的差异
6. 不断分析和调整，直至找到合适的JVM参数配置
7. 找到最合适的参数，将这些参数应用至所有服务器，并进行后续跟踪。



从满足程序的内存使用需求，之后是时间延迟的要求，最后才是吞吐量的要求。



### （4）参数解析及调优

例如：

```
-Xmx4g –Xms4g –Xmn1200m –Xss512k -XX:NewRatio=4 -XX:SurvivorRatio=8 -XX:PermSize=100m -XX:MaxPermSize=256m -XX:MaxTenuringThreshold=15
```

参数解析：

- -Xmx4g：堆内存最大值为4GB。 
- -Xms4g：初始化堆内存大小为4GB。 
- -Xmn1200m：设置年轻代大小为1200MB。增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。 
- -Xss512k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1MB，以前每个线程堆栈大小为256K。应根据应用线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。 
- -XX:NewRatio=4：设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5 
- -XX:SurvivorRatio=8：设置年轻代中Eden区与Survivor区的大小比值。设置为8，则两个Survivor区与一个Eden区的比值为2:8，一个Survivor区占整个年轻代的1/10 
- -XX:PermSize=100m：初始化永久代大小为100MB。 
- -XX:MaxPermSize=256m：设置持久代大小为256MB。 
- -XX:MaxTenuringThreshold=15：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。



**可调优参数：**

-Xms：初始化堆内存大小，默认为物理内存的1/64(小于1GB)。

-Xmx：堆内存最大值。默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。

-Xmn：新生代大小，包括Eden区与2个Survivor区。

-XX:SurvivorRatio=1：Eden区与一个Survivor区比值为1:1。

-XX:MaxDirectMemorySize=1G：直接内存。报java.lang.OutOfMemoryError: Direct buffer memory异常可以上调这个值。

-XX:+DisableExplicitGC：禁止运行期显式地调用System.gc()来触发fulll GC。

注意: Java RMI的定时GC触发机制可通过配置-Dsun.rmi.dgc.server.gcInterval=86400来控制触发的时间。

-XX:CMSInitiatingOccupancyFraction=60：老年代内存回收阈值，默认值为68。

-XX:ConcGCThreads=4：CMS垃圾回收器并行线程线，推荐值为CPU核心数。

-XX:ParallelGCThreads=8：新生代并行收集器的线程数。

-XX:MaxTenuringThreshold=10：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。

-XX:CMSFullGCsBeforeCompaction=4：指定进行多少次fullGC之后，进行tenured区 内存空间压缩。

-XX:CMSMaxAbortablePrecleanTime=500：当abortable-preclean预清理阶段执行达到这个时间时就会结束。

在设置的时候，如果关注性能开销的话，应尽量把永久代的初始值与最大值设置为同一值，因为永久代的大小调整需要进行FullGC才能实现。



### （5）内存优化示例

 ![image](typora-user-images/1) 

以上gc日志中，在发生fullGC之时，整个应用的堆占用以及GC时间。为了更加精确需多次收集，计算平均值。或者是采用耗时最长的一次FullGC来进行估算。上图中，老年代空间占用在93168kb（约93MB），以此定为老年代空间的活跃数据。则其他堆空间的分配，基于以下规则来进行。

- java heap：参数-Xms和-Xmx，建议扩大至3-4倍FullGC后的老年代空间占用。 
- 永久代：-XX:PermSize和-XX:MaxPermSize，建议扩大至1.2-1.5倍FullGc后的永久代空间占用。 
- 新生代：-Xmn，建议扩大至1-1.5倍FullGC之后的老年代空间占用。 
- 老年代：2-3倍FullGC后的老年代空间占用。

**注意：都是以FullGC后的空间占用为基础**



### （6）延迟优化示例

对延迟性优化，首先需要了解延迟性需求及可调优的指标有哪些。

- 应用程序可接受的平均停滞时间: 此时间与测量的Minor 
- GC持续时间进行比较。可接受的Minor GC频率：Minor 
- GC的频率与可容忍的值进行比较。 
- 可接受的最大停顿时间:最大停顿时间与最差情况下FullGC的持续时间进行比较。 
- 可接受的最大停顿发生的频率：基本就是FullGC的频率。 

其中，平均停滞时间和最大停顿时间，对用户体验最为重要

 对于上面的指标，相关数据采集包括：MinorGC的持续时间、统计MinorGC的次数、FullGC的最差持续时间、最差情况下，FullGC的频率。 



 新生代空间越大，Minor GC的GC时间越长，频率越低。如果想减少其持续时长，就需要减少其空间大小。如果想减小其频率，就需要加大其空间大小。 





### （7）吞吐量调优

吞吐量调优主要是基于应用程序的吞吐量要求而来的，应用程序应该有一个综合的吞吐指标，这个指标基于整个应用的需求和测试而衍生出来的。

评估当前吞吐量和目标差距是否巨大，如果在20%左右，可以修改参数，加大内存，再次从头调试，如果巨大就需要从整个应用层面来考虑，设计以及目标是否一致了，重新评估吞吐目标。

对于垃圾收集器来说，提升吞吐量的性能调优的目标就是尽可能避免或者很少发生FullGC或者Stop-The-World压缩式垃圾收集（CMS），因为这两种方式都会造成应用程序吞吐降低。尽量在MinorGC 阶段回收更多的对象，避免对象提升过快到老年代。







## 



















































